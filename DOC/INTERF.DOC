




                                



      Система программирования Рефал/2 для ПЭВМ IBM PC.
                  Интерфейс Рефала и Си.

                         -02-
      
      
      
      
  


                   С О Д Е Р Ж А Н И Е

    Введение . . . . . . . . . . . . . . . . . . . . . . . . .03
1.  Обработка ошибок . . . . . . . . . . . . . . . . . . . . .03 
2.  Представление выражений в памяти машины. . . . . . . . . .04
3.  Доступ к полям звена из программы на Си. . . . . . . . . .05
4.  Представление функциональных скобок в списковой памяти . .08
5.  Представоение ящиков в списковой памяти. . . . . . . . . .09
6.  Печать выражений . . . . . . . . . . . . . . . . . . . . .10
7.  Процессы . . . . . . . . . . . . . . . . . . . . . . . . .10
8.  Общий блок refal . . . . . . . . . . . . . . . . . . . . .11
9.  Инициализация и терминация Рефал-системы . . . . . . . . .13
10. Пространство списковой памяти и список свободных звеньев .15
11. Таблица состояния процесса . . . . . . . . . . . . . . . .19
12. Создание и уничтожение процессов . . . . . . . . . . . . .21
13. Запуск процессов . . . . . . . . . . . . . . . . . . . . .22
14. Примеры управления процессами. . . . . . . . . . . . . . .24
15. Сборка мусора. . . . . . . . . . . . . . . . . . . . . . .26
16. Динамический захват списковой памяти . . . . . . . . . . .29
17. Вызов программ на Си из программ, написанных на Рефале . .30
18. Написание первичных функций на Си. . . . . . . . . . . . .31
19. Примеры первичных функций на Си. . . . . . . . . . . . . .33

                         -03-


                   Введение 

    
    В данном руководстве описаны средства, позволяющие  вызывать
из программ, написанных на Си, программы, написанные на Рефале и
наоборот. 
    Интерфейс между Рефалом и Си основан на понятии  п р о ц е с
с а. Процессом называется совокупность поля зрения и копилки. 
    В каждый момент времени работает либо Си-программа, либо Ре-
фал-программа. Когда управление  принадлежит  Си-программе,  все
процессы приостановлены. Когда работает Рефал-программа, работа-
ет ровно один из процессов. 
    Си-программа может создавать и уничтожать  процессы,  запус-
кать  их и исследовать причины их остановки. При обращении из Си
к Рефалу, из Си вызывается не Рефал-функция, а процесс, т.е. по-
ле  зрения,  в котором уже находятся обращения к Рефал-функциям.
Таким образом, содержимое поля зрения определяет,  какие  именно
функции будут вызваны. 
    Си-программа  обязана сформировать начальное поле зрения пе-
ред обращением к Рефалу, а затем, когда Рефал вернет ей управле-
ние, извлечь нужную информацию из поля зрения. 
    Если  же Рефал-программа обращается к Си-программе, то ли же
Рефал-программа обращается к Си-программе, то Си-программа долж-
на  сама  извлечь  нужную информацию из ведущего функционального
терма и перед возвратом управления Рефал-программе  сформировать
результат замены. 
      
                   1. Обработка ошибок 
      
    Во многих случаях Рефал-система обнаруживает фатальные ошиб-
ки, которые делают бессмысленным продолжение ее работы.  В  этих
случаях  печатается  диагностическое сообщение и работа Си-прог-
раммы на этом завершается. Для выполнения вышеописанных действий
удобно использовать следующую программу. 

    П о д п р о г р а м м а  rfabe. 
    
  Назначение. 
    Печатает сообщение и завершает работу программы. 
  Обращение. 
    rfabe (text);
  Параметры.
    text - текст сообщения.
  Использование. 
    Начиная  с  первой позиции печатается текст "*** refal-abend
***", а вслед за ним -текст сообщения. 
  Исходный текст.

         rfabe (text)
          char *text;
          {
           printf ("\n *** refal-abend *** %s",text);
           exit(0);
          }

                         -04-

      
                   2. Представление выражений в памяти машины 

    Во время работы Рефал-программы поле зрения, копилка и ящики
представлены  в виде списков. Минимальной нерасчленимой единицей
является з в е н о. Каждое звено занимает  семь  слов,  т.е.  14
байтов. 
    Звено состоит из следующих полей 
             ----------------------------
             |  prev  |  next  |  code  |
             ----------------------------
    Поля  prev  и next используются для связывания звеньев в ли-
нейную последовательность. Поле next всегда содержит адрес  сле-
дующего звена, а поле prev -адрес предыдущего звена. Поля prev и
next занимают по два слова. 
    Поле code состоит из двух подполей: tag и info. 
             ---------------------------
             |  tag  |      info       |
             ---------------------------
    Поле tag занимает одно слово, а поле info - два  слова  поля
code. Их смысл зависит от того, какому объекту Рефала соответст-
вует данное звено. 
    Если звено принадлежит полю зрения, копилке или  содержимому
ящика,  оно может изображать один из следующих объектов: символ,
структурную скобку или функциональную скобку. 
    Поле tag содержит признак типа звена. если его пять  старших
разпядов- нулевые, звено называется стандартным. если же хотя бы
один из пяти старших разрядов поля tag отличен  от  нуля,  звено
именуется нестандартным. 
    Если звено стандартное, то поле tag имеет следующие значения
для объектов различных типов: 
      0 - символ-литера(объектный знак),
      2 - символ-метка(имя функции),
      4 - символ-число(макроцифра),
      6 - символ-ссылка,
      
      1 - левая структурная скобка "(",
      3 - правая структурная скобка ")",
      5 - левая функциональная скобка "k",
      7 - правая функциональная скобка ".".
                                                    
    Ноль в младшем разряде поля tag означает, что звено содержит
символ, а единица - что звено содержит скобку. 
    С  помощью первичных функций, написанных на Си или языке ас-
семблера, можно создавать нестандартные звенья, у которых  стар-
шие  пять  разрядов  поля tag имеют ненулевое значение. Если при
этом младший бит поля tag равен нулю, Рефал-система рассматрива-
ет такие звенья как некоторые составные символы,отличные от сим-
волов-меток, символов-чисел и символов-ссылок. поле  info  таких
звеньев может содержать произвольную комбинацию из тридцати двух
битов. при выводе выражений на печать эти символы изображаются в
виде 
         /ff%ffffffff/,
    где  ff  -  значение  поля  tag,  а  ffffffff- значение поля
info,выраженные в шестнадцатиричной системе счисления. 

                         -05-


    Таким образом, помимо четырёх  стандартных  типов  символов,
существует  ещё множество "нестандартных" типа символов. нестан-
дартные символы невозможно изобразить  в  виде  констант  в  Ре-
фал-программах.  Кроме  того, они являются специфической особен-
ностью только некоторых реализаций, поэтому их не стоит  исполь-
зовать при создании мобильных Рефал-программ. 
    При порождении нестандартных звеньев следует твёрдо помнить,
что младший разряд поля tag должен быть нулевым, ибо  употребле-
ние  нестандартных  звеньев  с нечётным значением поля tag может
вызвать непредсказуемые последствия. 
    Смысл поля tag зависит от типа звена. 
    *  для  структурной скобки поле info содержит адрес парной к
       ней скобки. 
    * для символа-литеры поле info в младшем байте содержит  код
      соответствующей  литеры  в коде ASCII, а старшие три байта
      равны нулю. 
    * для символа-метки поле info содержит адрес точки  входа  в
      соответствующую функцию, написанную на Рефале или Си. 
    * для символа-числа поле info содержит целое неотрицательное
      число, соответствующее телу этого символа-числа. 
    * для символа-ссылки поле info содержит адрес  головы  соот-
      ветствующего ящика. 
    *  для символа нестандартного типа поле info содержит произ-
       вольную (с точки зрения Рефал-системы) информацию. 
    о функциональных скобках будет сказано ниже.

   
                   3. Доступ к полям из программы на Си 
 
    Для того, чтобы извлекать или изменять содержимое звеньев  в
программах, написанных на Си, следует воспользоваться указателя-
ми и базированными структурами. 
    Структура звена описывается следующим образом: 
     struct linkcb_
      { struct linkcb_ *prev;
        struct linkcb_ *next;
        unsigned int tag;
        union
         { char infoc;
           int coden;
           struct linkcb_ *codep;
           char *codef;
         } info;
      };
     typedef struct linkcb_ linkcb;
    Эти описания следует либо непосредственно вставить  в  текст
программы  на Си, либо включить их в программу с помощью предло-
жения 
        #include "refal.def"
    Все последующие опредеения структур и макро-переменных также
находятся в файле refal.def. 
    Для  повышения  наглядности программ рекомендуется использо-
вать символические имена для признаков типов. например, вместо 5
- писать TAGK. Имена признаков описываются следующим образом: 

                         -06-


       #define TAGO  0
       #define TAGF  2
       #define TAGN  4
       #define TAGR  6
       #define TAGLB 1
       #define TAGRB 3
       #define TAGK  5
       #define TAGD  7
      
      
    П р и м е р 1. 
      
    Опишем подпрограмму, которая просматривает некоторое выраже-
ние и заменяет в нём все вхождения символа-литеры  '+'  на  сим-
вол-литеру '-'. 
    Обращение к подпрограмме должно иметь вид: 
            chpm (p, q);
    где  p  - указатель на звено,предшествующее выражению, а q -
указатель на звено,следующее за выражением. 
    Подпрограмма может быть описана следующим образом: 
      
      #include "refal.def"
      
      chpm (p, q)
       linkcb *p, *q;
      {
       linkcb *r;
      
       r = p ->next;
       while (r != q) {
            if (r ->tag == TAGO &&
                r ->info.infoc == '+')
               r ->info.infoc = '-';
            r = r ->next;
       }
      }
      
    П р и м е р 2. 
      
    Опишем подпрограмму bmatch, обращение к которой имеет вид: 
      bmatch (p, q);
    и  которая  просматривает   выражение,   заключённое   между
звеньями, на которые указывают p и q, и все символы-литеры '(' и
')' заменяет на структурные скобки ( и ). предполагается, что  в
исходном  выражении символы-литеры '(' и ')' образуют правильную
скобочную структуру. 

    #include "refal.def"
      
      bmatch (p, q)
       linkcb *p, *q;
      {
       linkcb *r, *r1, *lastb;

                         -07-

       
       lastb = NULL;
       r = p ->next;
       while (r != q) {
            if (r ->tag == TAGO &&
                r ->info.infoc == '(') {
                r ->info.codep = lastb;
                lastb = r;
            }
            else if (r ->tag == TAGO &&
                     r ->info.infoc == ')') {
                     r ->info.codep = lastb;
                     r ->tag = TAGRB;
                     r1 = lastb ->info.codep;
                     lastb ->info.codep = r;
                     lastb ->tag = TAGLB;
                     lastb = r1;
            }
            r = r ->next;
       }
      }

    П о д п р о г р а м м а rftpl. 
    
  Назначение.
    Переставляет указанную часть списка (трансплантат) в  другое
место. 
  Обращение.
    rftpl (r, p, q);
  Параметры.
    r - указатель на звено, после которого  вставляется  трансп-
        лантат; 
    p - указатель на звено, предшествующее трансплантату; 
    q - указатель на звено, следующее за трансплантатом. 
  Использование.
    Участок  списка,  заключенный  между  p  и q, исключается из
списка, звенья p и q сшиваются.  после  этого,  вынутый  участок
списка вставляется после звена r. 
  Исходный текст.
    #include "refal.def"
    rftpl(r,p,q)
     linkcb *p, *r, *q;
    {
     linkcb *r1, *q1, *p1;
     p1 = p->next;
     if ( p1 == q ) return;
     r1 = r->next;
     q1 = q->prev;
     p->next = q;
     q->prev = p;
     q1->next = r1;
     r1->prev = q1;
     r->next = p1;
     p1->prev = r;
    }

                         -08-
      

    Ф у н к ц и я lldupl. 
    
  Назначение.
    Позволяет  отделить  от  указанного выражения с левого конца
часть, совпадающую с другим указанным выражением. 
  Объявление.
    linkcb *lldupl();
  Обращение.
    lldupl(p,q,u);
  Параметры.
    p - указатель на звено, предшествующее выражению-оригиналу; 
    q - указатель на звено, следующее за выражением-оригиналом; 
    u - указатель на звено, предшествующее выражению, от которо-
        го должен быть отделён дубликат; 
    Возвращаемое значение - указатель на звено, следующее за вы-
       ражением-дубликатом 
  Использование.
    Пусть между p и q заключено выражение ex (именуемое оригина-
лом), а после u начинается некоторое выражение ey. если ey начи-
нается  с ex, т.е. его можно представить в виде ex ez, то lldupl
вырабатывает ненулевое значение указателя на звено, следущее  за
ex,  т.е.  на звено, с которого начинается ez. если же ey невоз-
можно представить в виде ex ez, то lldupl вырабатывает  значение
NULL, а u-остаётся без изменения. 
  Исходный текст.

    #include  "refal.def" 
    linkcb *lldupl(p,q,u) 
     linkcb *p,*q,*u;
    {
     linkcb *x,*y; 
     
     x = p->next; 
     y = u->next; 
     while ( x != q)  {  
          if (x->tag   !=   y->tag)   
             return(NULL);   
          if (x->info.codef  != y->info.codef) 
            if ((x->tag  !=  TAGLB)  &&  (x->tag  !=  TAGRB))
               return(NULL); 
          x = x->next; 
          y = y->next; 
     } 
     return (y); 
    } 
        
                   4. Представление функциональных
                      скобок в списковой памяти. 

    Функциональные  скобки  занимают по одному звену каждая. имя
функции хранится в виде символа-метки, сразу же вслед за  знаком
"k", и занимает отдельное звено. 

                         -09-


    Звено,  соответствующее знаку "k", содержит в поле tag приз-
нак TAGK. Звено, соответствующее знаку ".",содержит в  поле  tag
признак TAGD. 
    Знак  "."  в  поле  info содержит адрес первого к нему знака
"k". Знак "k" в поле info содержит адрес ".", который станет ве-
дущим,  после  полного вычисления данного функционального терма.
Если же такого "." не существует, знак "k" в поле info  содержит
нуль. 
    Таким образом, знаки "k" и "." связаны в список в том поряд-
ке, в котором они будут становиться ведущими. 


                   5. Представление ящиков в списковой памяти 

    Каждому ящику (как статическому, так и динамическому)  соот-
ветствует  звено, именуемое головой ящика. Это звено, как и вся-
кое другое, обязательно выравнено по границе слова. 
    Если ящик динамический, то его именем является  символ-ссыл-
ка.  символ-ссылка  в поле tag всегда содержит признак TAGR, а в
поле info -адрес головы соответствующего ящика. 
    Если ящик статический, то его именем является  символ-метка,
который  в  поле tag содержит признак TAGF, а в поле info- адрес
байта, предшествующего голове соответствующего ящика. 
    Байт, предшествующий голове статического ящика,  обязательно
содержит константу 0x8E, что даёт возможность проверить, являет-
ся ли символ-метка именем статического ящика. 
    Если к статическому ящику не было ни одного  обращения,  его
голова  содержит  нуль. при первой же попытке что-либо прочитать
из статического ящика или записать в него, голова  инициализиру-
ется:  в поля prev и next заносится адрес самой головы, что рав-
носильно записи в ящик пустого выражения. Только после этого вы-
полняется операция над ящиком. 
    Содержимым  ящика является некоторое выражение. Начало и ко-
нец этого выражения присоединены к голове ящика, т.е. поле  next
головы  ящика  содержит  адрес первого звена, а поле prev -адрес
последнего звена содержимого ящика. В тоже время,  первое  звено
содержимого ящика в поле prev и последнее звено содержимого ящи-
ка в поле next содержит адрес головы ящика. Таким образом, голо-
ва  ящика вместе с его содержимым представляют собой двухсвязный
циклический список. 
    Если содержимое ящика пустое, то голова ящика в полях prev и
next содержит свой собственный адрес. 
    В  поле tag головы ящика содержится 0x00. Это поле использу-
ется во время сборки мусора (см.п.15), чтобы помечать ящики, ко-
торые нельзя выбрасывать. 
    Для  сборки  мусора необходимо иметь возможность просмотреть
головы всех ящиков. Поэтому поля info в головах ящиков использу-
ются  для  того, чтобы связать все головы в односвязный список в
порядке, обратном порядке их порождения. Каждая  голова  в  поле
info  содержит адрес следующей головы. Если голова - последняя в
списке, то в поле info она содержит нуль. 

                         -10-


    Головы статических и головы динамических связаны в  два  от-
дельных  односвязных  списка.  Ссылки на эти списки содержатся в
общем блоке refal(см.п.8). Динамические ящики заносятся в список
в  момент создания, статические- в момент инициализации их голо-
вы. 


                   6. Печать выражений 

    П о д п р о г р а м м а rfpexm. 
    
  Назначение.
    Печатает выражение в метакоде-Б.
  Обращение.
    rfpexm (text, p, q);
  Параметры.
    text - текст, который печатается слева от выражения;
    p - указатель на звено, предшествующее  печатаемому  выраже-
        нию; 
    q - указатель на звено, следущее за печатаемым выражением.
  Использование.
    Участок  списка, заключённый между p и q , следующим образом
печатается в метакоде-Б. 
    Пусть l -длина текста text. тогда в первых l позициях  печа-
тается  текст  text, а вслед за ним выражение в метакоде-Б. Если
выражение не поместилось на одной  строке,  оно  переносится  на
следующие строки. 
      
    П о д п р о г р а м м а rfpex. 
    
  Назначение.
    Печатает выражение.
  Обращение.
    rfpex (text, p, q);
  Параметры.
    Те же, что и для подпрограммы rfpexm.
  Использование.
    Аналогично  подпрограмме  rfpexm.  разница  состоит только в
форме, в которой печатаются  выражения.  в  отличии  от  rfpexm,
rfpex не обрамляет цепочки символов-литер апострофами, а состав-
ные символы обрамляют апострофами вместо знаков "/". 
  
    7. Процессы. 

    Данная реализация Рефала позволяет создавать программы, раз-
личные  части  которых  написаны на Рефале и Си, и которые тесно
взаимодействуют друг с другом. 
    Программа на Си может вызывать программы  на  Рефале,  кото-
рые,в свою очередь, могут вызывать программы на Си и т.д. 
    В  каждый  момент времени могут существовать несколько полей
зрения и копилок. при этом каждому полю зрения соответствует од-
на копилка и наоборот. 

                         -11-


    Совокупность  из  поля  зрения  и  связанной с ним копилки в
дальнейшем именуется п р о ц е с с о м. 
    Программы на Си могут создавать и уничтожать  процессы,  за-
пускать  их  и исследовать причины их остановки. Программы,напи-
санные на Рефале, не могут управлять  процессами  непосредствен-
но,но могут делать это вызывая программы на Си. 
    Существует  возможность  запускать процесс на заданное число
шагов. Запуская процесс каждый раз только на  один  шаг  вперёд,
программа на Си может полностью контролировать его работу. 
    Для управления Рефал-процессами предоставляется набор проце-
дур (подпрограмм и функций), вызываемых из программ на  Си.  Эти
процедуры  хранят глобальную информацию в общем блоке refal. Для
каждого процесса имеется таблица состояния процесса,  в  которой
содержится вся необходимая информация о процессе. 


                   8. Общий блок refal 

    Программы  на Си, взаимодействующие с Рефал-программами, ис-
пользуют общий блок refal, который должен быть описан  следующим
образом. 

     struct refal_
      { st *crprev;
        st *crnext;
        int upshot;
        linkcb *preva;
        linkcb *nexta;
        linkcb *prevr;
        linkcb *nextr;
        st *currst;
        linkcb *flhead;
        linkcb *svar;
        linkcb *dvar;
        int stmnmb;
        int nostm;
        int tmmode;
        int tmintv;
      };
     typedef struct refal_ REFAL;
      
    Это описание может быть включено в программу на Си непосред-
ственно, либо с помощью макро-предложения. 
       #include "refal.def"
    Первоначальное заполнение общего блока refal происходит  при
вызове  подпрограммы rfinit, либо в момент создания первого про-
цесса, либо в момент первого выделения пространства под  списко-
вую память. 
    Отдельные  слова общего блока refal имеют следующее содержи-
мое. 
    crprev - адрес последней таблицы состояния. 
    crnext - адрес первой таблицы состояния. 
    upshot - результат вызова из Рефала программы, написанной на
             Си. может принимать целые значения 1, 2 и 3: 

                         -12-


             1 - вычисление окончено;
             2 - отождествление невозможно;
             3 - свободная память исчерпана.
    preva - адрес звена, предшествующего аргументу функции, т.е.
            звена, содержащего имя функции. 
    nexta - адрес звена, следующего за аргументом, т.е. звена,
            содержащего знак ".". 
    prevr - адрес звена, предшествующего результату замены. этим
            звеном  является звено, предшествующее знаку "k" пе-
            ред началом шага. 
    nextr - адрес звена, следующего за результатом замены. этим
            звеном является звено,содержащее знак "k". 
    currst - адрес текущей таблицы состояния, т.е. таблицы  сос-
            тояния  того Рефал-процесса, который вызвал работаю-
            щую в данный момент программу на Си. Если  же  прог-
            рамма на Си вызвана не из рефал-программы, 
            то currst = NULL. 
    flhead - адрес звена, являющегося  головой  списка  свободных
            звеньев. 
    svar  - ссылка на первый елемент односвязного списка стати-
            ческих  ящиков.  Ящики заносятся в этот список в мо-
            мент первого обращения и расположены в порядке,  об-
            ратном  к тому, в котором происходили первые обраще-
            ния. если небыло ни одного обращения  к  статическим
            ящикам, svar = NULL. 
    dvar  - ссылка на первый елемент односвязного списка динами-
            ческих  ящиков.  Ящики заносятся в этот список в мо-
            мент создания и расположены в  порядке,  обратном  к
            тому,  в котором они создавались. если нет ни одного
            динамического ящика, dvar = NULL. 
    stmnmb - номер Рефал-предложения, которое было применено при
            выполнении шага Рефал-машины. предложения  в  каждой
            функции нумеруются начиная с 1. 
    nostm - общее количество предложений  в  той  Рефал-функции,
            которая была вызвана при выполнении шага Рефал-маши-
            ны. 
    tmmode  - признак того, что следует измерить время централь-
            ного процессора, израсходованное  между  запуском  и
            остановкой интерпретатора языка сборки. Может прини-
            мать целые значения 0 и 1. 
            0- время измерять не нужно; 
            1- время измерять нужно. 
    tmintv - время центрального процессора, израсходованное меж-
            ду запуском и остановкой интерпретатора языка  сбор-
            ки,   выраженное  в  микросекундах.  устанавливается
            только если  tmmode=1.  
    Назначение и  использование  различных  полей  общего  блока
refal более подробно объясняется в следующих разделах. 



                         -13-


                   9. Инициализация и терминация 
                            Рефал-системы 

    В  начале  работы  Рефал-системы её необходимо инициализиро-
вать, т.е. привести в рабочее состояние, а в конце работы-  тер-
минировать,  т.е. привести в нерабочее состояние и подготовить к
последующей инициализации. 

    П о д п р о г р а м м а rfinit. 
    
  Назначение.
    Инициализирует Рефал-систему.
  Обращение.
    rfinit();
  Параметры.
    Параметров нет.
  Использование.
    Заносятся начальные значения в общий блок refal и  создаётся
пустой список свободной памяти. 
  Исходный текст.
  
    #include  "refal.def"
    
    linkcb  hd;
    int rf_init = 1; 
    REFAL refal; 
    
    rfinit () 
    {
     REFAL *p; 
     linkcb  *phd;  
     rf_init  =  0;  
     p  = &refal;  
     p->crprev = &refal; 
     p->crnext = &refal; 
     p->upshot = 1;
     p->currst = NULL; 
     p->svar   = NULL; 
     p->dvar   = NULL;  
     p->flhead = &hd;  
     phd       = &hd; 
     phd->prev = phd; 
     phd->next = phd; 
     phd->tag  = 0;
     phd->info.coden = 0; 
     p->nostm  = 0; 
     p->stmnmb = 0; 
     p->tmmode = 0;
     p->tmintv = 0; 
    } 

                         -14-

     
    П о д п р о г р а м м а rfterm. 
    
  Назначение.
    Терминирует Рефал-систему.
  Обращение.
    rfterm();
  Параметры.
    Параметров нет.
  Использование.
    Рефал-система подготавливается к последующей инициализации. 
  Исходный текст.
  
    rfterm()
    {
     rf_init = 1;
    }

    

                   10. Пространство списковой памяти
                         и список свободных звеньев 


    Под  список  выделяются  один или несколько связных участков
памяти с помощью подпрограммы rflist. 
    При этом все неиспользованные звенья связаны с помощью полей
prev  и  next  в двусвязный циклический список (список свободной
памяти). В общем блоке refal в поле flhead содержится ссылка  на
звено - голову этого списка. 
    При отведении под список нового участка памяти, новые звенья
связываются в список и вставляются в конец списка свободной  па-
мяти.

    П о д п р о г р а м м а rflist. 
    
  Назначение.
    Отдаёт под список новый связный участок памяти.
  Обращение.
  Параметры.
    array - массив слов, отдаваемый под списковую память.
    n - количество звеньев, которое необходимо получить из
        этого массива. 
  Использование.
    Слова,  составляющие  массив array, разбиваются на группы по
размеру звена, и из каждой такой группы создаётся звено, которое
включается в список свободной памяти. 
  Замечание.
    Если при обращении к rflist, общий блок refal ещё не инициа-
лизирован, производится его инициализация. 

                         -15-


  Исходный текст.
   #include "refal.def"
      extern REFAL refal;   
   rflist(array,n)
    linkcb *array;
    int n;
    {
     extern int rf_init;
     linkcb *p, *q;
     int k;
     if (rf_init != 0) rfinit();
     q = array;
     p = refal.flhead->prev;
     for (k = 1; k<=n; k++)
      {   p->next = q;
          q->prev = p;
          q->tag = 0;
          q->info.codep = NULL;
          p = q;
          q++;
      }
     p->next = refal.flhead;
     refal.flhead->prev = p;
    }
    
    Ф у н к ц и я lrqlk. 
    
  Назначение.
    Проверяет, содержит ли список  свободных  звеньев  указанное
количество звеньев. 
  Обращение.
    lrqlk (l);
  Параметры.
    l- количество запрашиваемых звеньев.
  Использование.
    Если  список  свободных  звеньев  содержит  не меньше, чем l
звеньев (не считая головы), функция вырабатывает значение  1,  в
противном случае - значение 0. 
  Исходный текст.
    #include "refal.def"
    lrqlk (l) 
     int l; 
    { 
      extern REFAL refal;
      linkcb *p;
      int n;
      p = refal.flhead;
      for (n = 1; n<=l; n++) {
       p = p->next;
       if ( p == refal.flhead)
        return (0);
      }
      return (1);
    }  

                         -16-

      
    П о д п р о г р а м м а rfdel. 
    
  Назначение.
    Удаляет указанную часть списка и заносит её в список свобод-
ных звеньев. 
  Обращение.
    rfdel (p, q);
  Параметры.
    p - указатель на звено, предшествующее удаляемой части спис-
        ка; 
    q  - указатель на звено, следующее за удаляемой частью спис-
        ка. 
  Использование.
    Участок списка, заключённый между звеньями p и q, исключают-
ся из списка, звенья p и q сшиваются, после чего вынутый участок
списка вставляется в конец списка свободной памяти. 
  Исходный текст.
      
    #include "refal.def"
    rfdel (p,q)
     linkcb *p,*q;
     {
      extern REFAL refal;
      linkcb *p1,*q1,*r;
    
      p1 = p->next;
      if (p1 == q) return;
      q1 = q->prev;
      r = refal.flhead->prev;
      p->next = q;
      q->prev = p;
      q1->next = refal.flhead;
      refal.flhead->prev = q1;
      r->next = p1;
      p1->prev = r;
    }
      
    Ф у н к ц и я lcopy. 
    
  Назначение.
    Копирует указанное выражение и вставляет копию  в  указанное
место. 
  Обращение.
    lcopy (r,p,q);
  Параметры.
    r - указатель на звено, после которого вставляется копия; 
    p - указатель на звено, предшествующее копируемому выраже-
        нию; 
    q - указатель на звено, следующее за копируемым выражением. 
  Использование.
    Если список свободной памяти содержит достаточное количество
звеньев, выражение, заключённое между p и q, копируется и встав-
ляется после r. При этом функция вырабатывает значение 1. В про-
тивном случае функция ничего не делает и вырабатывает значение 0. 

                         -17-


  Исходный текст.
      
    #include "refal.def"
    lcopy (r,p,q)
     linkcb *r,*p,*q;
     {
      extern REFAL refal;
     linkcb *r1,*f,*f0,*f1,*lastb;
    
     f = refal.flhead;
     f0 =  p->next;
     while (f0 != q) {
      f = f->next;
      if (f == refal.flhead) return(0);
      switch (f0->tag) {
       
       case TAGLB:
        f->info.codep = lastb;
        lastb = f;
        break;
    
       case TAGRB:
        f->info.codep = lastb;
        f->tag = TAGRB;
        f1 = lastb->info.codep;
        lastb->info.codep = f;
        lastb->tag = TAGLB;
        lastb = f1;
        break;
    
       default:
        f->tag = f0->tag;
        f->info.codep = f0->info.codep;
      }
      f0 = f0->next;
     }
     if (refal.flhead == f) return(1);
     f0 = refal.flhead->next;
     f1 = f->next;
     refal.flhead->next = f1;
     f1->prev = refal.flhead;
     r1 = r->next;
     f->next = r1;
     r1->prev = f;
     r->next = f0;
     f0->prev = r;
     return(1);
    }

                         -18-
      

    Ф у н к ц и я lins. 
    
  Назначение.
    Вставляет указанное число звеньев из списка свободной памяти
после указанного звена. 
  Обращение.
    lins (p,l);
  Параметры.
    p - указатель на звено, после которого вставляются звенья; 
    l - количество вставляемых звеньев. 
  Использование.
    Если  в  списке  свободных  звеньев  имеется  не менее чем l
звеньев (не считая головы списка), функция вставляет  l  звеньев
после  звена,  на  которое  указывает p. В этом случае значением
lins является 1, а все вставленные звенья содержат NULL. Если  в
списке свободных звеньев не набирается l звеньев, функция ничего
не делает и вырабатывает значение 0. 
  Замечания.
    (1) в результате работы lins ни p, ни l не меняются. 
    (2) если l < 1, lins ничего не делает и вырабатывает  значе-
        ние 1. 
    (3) поля code во всех вставленных звеньях содержат значение
        NULL. 
  Исходный текст.
  
    #include "refal.def"

    lins (p,l)
     linkcb *p;
     int l;
     {
      extern REFAL refal;
      int n;
      linkcb *p1,*q,*q1,*r;
      
      if (l<1) return (1);
      q1 = refal.flhead;
      for (n=1; n<=l; n++) {
       q1 = q1->next;
       if (q1 == refal.flhead) return (0);
       q1->tag = TAGO;
       q1->info.codep = NULL;
      }
      r = q1->next;
      q = refal.flhead->next;
      refal.flhead->next = r;
      r->prev = refal.flhead;
      p1 = p->next;
      q1->next = p1;
      p1->prev = q1;
      p->next = q;
      q->prev = p;
      return (1);
     }

                         -19-
      
      
                   11. Таблица состояния процесса 

    Каждому  процессу  соответствует  таблица состояния процесса
(STATUS TABLE), которая должна быть  описана  следующим  образом
(находится также в файле refal.def). 

    struct  st_  { 
      struct  st_ *stprev; 
      struct st_ *stnext; 
      int state; 
      linkcb *dot; 
      long step; 
      long stop; 
      linkcb  *view;  
      linkcb *store; 
    }; 
    typedef struct st_ st; 
      
    Отдельные поля таблицы состояния имеют следущее содержимое. 
    stprev - адрес предыдущей таблицы состояния. 
    stnext - адрес следующей таблицы состояния. 
    state - состояние процесса - одно из целых чисел 1, 2, 3, 4,
            имеющих следующий смысл: 
            1 - процесс остановился в результате того, что в по-
                ле зрения не осталось ни одного  знака  "k"  или
                из-за того, что перед началом шага оказалось вы-
                полнено условие st.step = st.stop. 
            2 - процесс остановился из-за того, что отождествле-
                ние невозможно. 
            3 - процесс остановился из-за того, что список  сво-
                бодной памяти  содержит  слишком  мало  звеньев,
                вследствии  чего невозможно сформировать резуль-
                тат замены ведущего функционального терма. 
            4  -  процесс находится в активном состоянии, т.е. в
                середине выполнения шага. В частности это  может
                означать,  что  процесс вызвал программу на Си и
                ожидает, когда эта программа вернёт управление. 
    dot - адрес ведущей точки. 
          в состоянии 1 содержит адрес ведущей точки,  если  она
          есть,  а  если  в поле зрения нет ни одного знака ".",
          dot = NULL. 
          в состоянии 2 или 3 содержит адрес ведущей точки. 
          в состоянии 4 значение dot не определено. 
    step - счётчик числа шагов. показывает  количество  уже  за-
          вершённых шагов. 
    stop  - предельный номер шага. Если перед началом выполнения
          очередного  шага оказывается, что step = stop, то оче-
          редной шаг выполняться не будет, а процесс остановится
          в состоянии 1. 
    view - адрес головы поля зрения. 
    store - адрес головы копилки. 
    Все  таблицы состояния связаны в двусвязный циклический спи-
сок, головой которого является общий блок refal. Для  этого  ис-
пользуются  поля crprev и crnext общего блока refal и поля strev

                         -20-


и stnext таблиц состояния процессов. 
    Поле зрения представляет собой двусвязный  циклический  спи-
сок.  головой  этого  списка является звено, которое в поле next
содержит адрес первого звена поля зрения, а в поле  prev-  адрес
последнего звена поля зрения. Точно так же устроена и копилка. 
      
    Ф у н к ц и я lexist. 
    
  Назначение.
    Позволяет узнать, является ли её параметр таблицей состояния
какого-нибудь из процессов. 
  Обращение.
    lexist (&st);
  Параметры.
    st- таблица состояния процесса. 
  Использование.
    Функция просматривает список таблиц состояния, головой кото-
рого  является общий блок refal, и вырабатывает значение 1, если
найдёт st в этом списке, в противном случае вырабатываеся значе-
ние 0. 
  Исходный текст.

    #include "refal.def"
    lexist (ast)
     st *ast;
     {
     extern REFAL refal;
     REFAL *p;
    
      p = &refal;
      do {
       p =p->crnext;
       if (p == ast) return (1);
      } while (p != &refal);
      return(0);
    }

    
                   12. Создание и уничтожение процессов 

    Ф у н к ц и я lcre. 
    
  Назначение.
    Создаёт процесс.
  Обращение.
    lcre (&st);
  Параметры.
    st - таблица состояния процесса.
  Использование.
    Если список свободных звеньев содержит достаточное количест-
во звеньев, lcre создаёт новый процесс и  вырабатывает  значение
1, в противном случае - ничего не делает и вырабатывает значение
0. 

                         -21-


  Замечания.
    (1) если до обращения к lcre общий блок refal не был инициа-
        лизирован, lcre предварительно инициализирует его. 
    (2) у только что созданного процесса поле зрения и копилка -
        пустые. 
  Исходный текст.
      
    #include "refal.def"
    
    lcre (ast)
     st *ast;
     {
      extern REFAL refal;
      extern int rf_init;
    
      st *q;
      linkcb *flhead1;
      
      if (rf_init ==1) rfinit();
      if (lexist(ast) == 1)
            rfabe ("rfabe: process already exists");
      ast->view = refal.flhead->next;
      if (ast->view == refal.flhead) return(0);
      ast->store = ast->view->next;
      if (ast->store == refal.flhead) return (0);
      flhead1 = ast->store->next;
      refal.flhead->next = flhead1;
      flhead1->prev = refal.flhead;
      (ast->view->next) = (ast->view); 
      (ast->view->prev) = (ast->view);
      (ast->store->next) =(ast->store); 
      (ast->store->prev) = (ast->store);
      q = refal.crprev;
      ast->stnext = &refal;
      refal.crprev = ast;
      q->stnext = ast;
      ast->stprev = q;
      ast->state = 1;
      ast->dot = NULL;
      ast->step = 0L;
      ast->stop = -1L;
      return (1);
     }
      
    П о д п р о г р а м м а rfcanc. 
    
  Назначение.
    Уничтожает процесс.
  Обращение.
    rfcanc (&st);
  Параметры.
    st - таблица состояния процесса.

                         -22-


  Использование.
    В результате обращения к rfcanc,  процесс,  имеющий  таблицу
состояния st, уничтожается. При этом память, которая была занята
под поле зрения и копилку, освобождается. Освободившиеся  звенья
присоединяются в конец списка свободных звеньев. 
  Замечания.
    (1)  можно  уничтожать  процесс,  только если он находится в
        состоянии 1, 2 или 3. Процесс, находящийся в состоянии 4
        уничтожать нельзя. 
    (2)  если  при  обращении  к rfcanc, общий блок refal ещё не
        инициализирован, производится его инициализация. 
  Исходный текст.
 
    #include "refal.def"
    rfcanc (ast)
     st *ast;
     {
      extern REFAL refal;
      extern int rf_init;
      linkcb *flhead1,*view1,*store1;
      
      if (rf_init) rfinit ();
      if (!lexist(ast))
             rfabe (" rfcanc: process doesn't exist");
      if (ast->state == 4)
            rfabe (" rfcanc: process is in job yet");
      ast->stprev->stnext = ast->stnext;
      ast->stnext->stprev = ast->stprev;
      flhead1 = refal.flhead->prev;
      view1 = ast->view->prev;
      store1 = ast->store->prev;
      flhead1->next = ast->view;
      ast->view->prev = flhead1;
      view1->next = ast->store;
      ast->store->prev = view1;
      store1->next = refal.flhead;
      refal.flhead->prev = store1;
     }

      
                   13. Запуск процессов 

    П о д п р о г р а м м а rfrun. 
    
  Назначение.
    Запускает процесс и ждёт пока он остановится.
  Обращение.
    rfrun (&st);
  Параметры.
    st - таблица состояния процесса.
  Использование.
    Подпрограмма служит для того, чтобы запустить процесс, имею-
щий таблицу состояния st. 

                         -23-


    После обращения к rfrun процесс начинает работать, пока либо
в поле зрения не останется знаков "k",либо будет невозможно  вы-
полнить   синтаксическое   отождествление,  либо  окажется,  что
st.step = st.stop, либо в списке свободной памяти  окажется  не-
достаточное количество звеньев для формирования результата заме-
ны. 
  Замечания.
    (1) после останова процесса выполняется оператор,  следующий
        за вызовом подпрограммы rfrun. 
    (2)  если  при  обращении к rfrun, st.dot = null,т.е. в поле
        зрения  нет  ни  одного  знака "k", то после обращения к
        rfrun всё остаётся без изменения, за  исключением  того,
        что процесс переходит в состоянии 1. 
    (3) к rfrun можно обращаться рекурсивно.
    (4) если при обращении к rfrun, st.state = 4, то rfrun ниче-
        го  не делает и после возврата из rfrun процесс остаётся
        в состоянии 4. 
    (5) при исполнении тех Рефал-функций, при компиляции которых
        была задана опция "c", в  stmnmb  заносится  номер  при-
        менённого предложения, а в nostm- количество предложений
        в функции. если же при  компиляции  Рефал-функции  опция
        "с"  не  была задана, или функция написана не на Рефале,
        stmnmb и nostm не изменяются. 
      
    Ф у н к ц и я linskd. 
    
  Назначение.
    Вставляет в поле зрения "k","." и имя функции.   
  Обращение.
    linskd (&st, &f);
  Параметры.
    st - таблица состояния процесса;
    f -  имя функции.
  Использование.
    Функция проверяет, что st.dot = NULL, что в поле зрения  нет
ни одного знака ".". 
    Затем  если в списке свободной памяти содержится достаточное
количество звеньев, она вставляет перед содержимым  поля  зрения
"k/f/",  а  после  содержимого поля зрения - ".". Таким образом,
если поле зрения содержало выражение  ex,  оно  приобретает  вид
"k/f/ ex.". 
    После этого linskd завершает работу, причём её значением яв-
ляется 1. Если же звеньев в списке свободных звеньев недостаточ-
но, linskd ничего не делает и вырабатывает значение 0. 

                         -24-


  Исходный текст.
      
    #include "refal.def"
    linskd (ast,f)
     st *ast;
     char *f;
     {
      linkcb *p,*q,*r;
      extern REFAL refal;  
      
       if (lexist(ast) == 0)
           rfabe ("linskd: process not found");
       if (ast->dot!=NULL)
           rfabe ("linskd: there are 'k'-signes in view field");
       if (lrqlk(3) == 0) return (0);
       lins (ast->view,3);
       p= ast->view->next;
       r = p->next;
       q = ast->view->prev;
       p->tag = TAGK;
       q->tag = TAGD;
       q->info.codep = p;
       r->tag = TAGF;
       r->info.codep = f;
       ast->dot = q;
       return (1);
     }


                   14. Примеры управления процессами 

    Следующая  программа создаёт процесс, запускает его, а затем
печатает причину его остановки. затем печатаются поле  зрения  и
копилка в метакоде-Б и процесс уничтожается. 
    Перед  началом  каждого шага печатается номер шага и ведущий
функциональный терм. В конце каждого шага  печатается  результат
замены  ведущего функционального терма. Всё это достигается тем,
что программа на Си запускает Рефал-процесс каждый раз только на
один шаг. 

    #include "refal.def"
    extern char job;
    
    main()
    {     
     st st1;
     linkcb *prevk, *nextd, *pk;
     linkcb arr[1000];

                         -25-

     
     rfinit();
     rflist (arr, 1000);
     if (lcre (&st1)) goto LACK;
     if (linskd (&st1, &job) {
        rfcanc(&st1);
        goto LACK;
     }
     while (st1.state == 1 && st1.dot != NULL) {
          st1.stop = st1.step + 1;
          pk = st1.dot ->info.codep;
          prevk = pk ->prev;
          nextd = st1.dot ->next;
          printf ("\n step: %d", st1.stop);
          rfpexm (" Term: ", prevk, nextd);
          rfrun (&st1);
          if (st1.state == 1)
             rfpexm (" Result: ", prevk, nextd);
     }
     switch (st1.state) {
           case 1:
             printf ("\n computation ended");
             break;
           case 2:
             printf ("\n recognition impossible");
             break;
           case 3:
             printf ("\n free memory exhausted");
     }
     rfpexm ("view field: ", st1.view, st1.view);
     rfpexm ("burried: ", st1.store, st1.store);
     rfcanc (&st1);
     rfterm();
     return;
    LACK:
     printf ("\n no memory for initialization");
     rfterm();
    }

    Предполагается, что существует Рефал-модуль, в котором опре-
делена как входная точка метка job. Сборка мусора не  предусмот-
рена. Память под список выделяется в массиве arr. 
          
    Теперь рассмотрим программу, которая создаёт два одновремен-
но существующих процесса и заставляет их работать  одновременно,
т.е. делая шаги поочередно. Таким образом, первый процесс делает
шаг и останавливается, затем второй процесс делает шаг  и  оста-
навливается и т.д. 
    Если  один из процессов заканчивается раньше другого, он до-
жидается окончания второго процесса. это достигается за счёт то-
го, что rfrun ничего не делает, если st.dot = NULL. 

                         -26-

 
    #include "refal.def"
    extern char func1, func2;
    
    main()
    {
     st st1, st2;
     linkcb *prevk, *nextd, *pk;
     linkcb arr[1000];
     
     rfinit();
     rflist (arr, 1000);
     lcre (&st1);
     lcre (&st2);
     linskd (&st1, &func1); 
     linskd (&st2, &func2);
     while (st1.dot != NULL || st2.dot != NULL) {
          st1.stop = st1.step + 1;
          st2.stop = st2.step + 1;
          rfrun (&st1;
          rfrun (&st2);
     }
     rfcanc (&st1);
     rfcanc (&st2);
     rfterm();
    }

    В этой программе предполагается, что список свободной памяти
достаточно велик, и что ни один из процессов  не  может  остано-
виться в состоянии 2 или 3. При желании в программу нетрудно до-
бавить соответствующие проверки. 


                   15. Сборка мусора 

    В тех случаях, когда Рефал-программа использует динамические
ящики и символы-ссылки, причём некоторые ящики могут становиться
ненуж- ными, следует предусмотреть сборку мусора в  те  моменты,
когда исчерпывается список свободных звеньев. 

    Ф у н к ц и я lgcl. 
    
  Назначение.
    Производит сборку мусора.
  Обращение.
    lgcl();
  Параметры.
    Параметров нет.
  Использование.
    В  результате  обращения производится сборка мусора. Сначала
помечаются головы всех динамических  ящиков,  до  которых  можно
добраться из какого-нибудь поля зрения, копилки или статического
ящика. Затем все ящики, оставшиеся непомеченными,  уничтожаются,
а освободившиеся звенья присоединяются к началу списка свободных
звеньев. 

                         -27-


    Если в результате сборки мусора высвободилось хоть одно зве-
но, функция вырабатывает значение 1, в противном случае - значе-
ние 0. 
  Исходный текст.

    #include "refal.def"
    lgcl()
     {
      extern REFAL refal;
      st *p;
      int was_coll;
      linkcb *pzero;
      linkcb *q,*r,*flhead1,*p1;
      linkcb hdvar, *hd;
    
      hd = &hdvar;
      if(refal.dvar == NULL) return(0);
    /* mark boxes achieved from view field & burriage */
      was_coll = 0;
      pzero = NULL;
      p = refal.crnext;
      while (p != &refal) {
         mark(p->view);
         mark(p->store);
         p = p->stnext;
      }
    /* mark boxes achieved from static boxes    */
      if (refal.svar != NULL) {
         r = refal.svar;
         do {
             mark(r);
             r = r->info.codep;
            } while(r != pzero);
                                  /*   remove garbage   */
          hd->info.codep = refal.dvar;
          p1 = hd;
          q = refal.dvar;
          do {
              if(q->tag != 0) {   /* box isn't remaved   */
                q->tag = 0;
                p1 = q;
              }
              else {                      /* remove box  */
                was_coll = 1;
                p1->info.codep = q->info.codep;
                p1->tag = q->tag;
                r = q->prev;
                flhead1 = refal.flhead->next;
                r->next = flhead1;
                flhead1->prev = r;
                refal.flhead->next = q;

                         -28-


                q->prev = refal.flhead;
                }
              q = p1->info.codep;
            } while (q != pzero);
       if (hd->info.codep == pzero)
          refal.dvar = NULL;
       else
           refal.dvar = hd->info.codep;
       return(was_coll);
       }
     }
    
    static mark(root)
     linkcb *root;
     {
      linkcb *h,*p,*q,*r;
      
          h = p = root;
    MRK:
          if(p->next == h) goto UP;
          p = p->next;
          if (p->tag != TAGR) goto MRK;
          q = p->info.codep;
          if (q->tag != 0) goto MRK;
          q->tag = 0xFFFF;
          p->info.codep = h;
          q->prev = p;
          h = p = q;
          goto MRK;
    UP:   if (h == root) return;
          q = h->prev;
          h->prev = p;
          r = h;
          h = q->info.codep;
          q->info.codep = r;
          q->tag = TAGR;
          p = q;
          goto MRK;      
     }

    П р и м е р. 

    Можно исправить программу exmpl2 так, чтобы она собирала му-
сор  в случае, если процесс остановился в состоянии 3. Для этого
достаточно строчку 

    rfrun(&st1);
   
заменить на последовательность операторов

    AGAIN:
      rfrun (&st1);
      if (st1.state == 3)
         if (lgcl()) goto AGAIN;

                         -29-


                   16. Динамический захват
                         списковой памяти 

    Ф у н к ц и я lincrm 
                                                    
  Назначение
    Пытается увеличить размер списка свободной памяти с  помощью
сборки мусора и захвата дополнительной памяти. 
  Обращение
    lincrm();
  Параметры
    Параметров нет
  Использование
    Пытается  увеличить размер списка свободной памяти с помощью
сборки мусора и захвата дополнительной памяти. Если это  удается
- вырабатывает значение 1, в противном случае - 0. 
  Замечание
    Если  первое  обращение к lincrm происходит до инициализации
Рефал-системы, и при этом удается  создать  начальную  списковую
память,  производится предварительная инициализация Рефал-систе-
мы. 
  Исходный текст
      
    #include "refal.def"
    
    linkcb *last_block = NULL;
    int curr_size = 0;
    extern REFAL refal;
    linkcb *malloc();
    
    lincrm()
     {
      linkcb *first_free, *p;
      linkcb *new_block,*work_var;
      int was_coll, n ;
      if (last_block != NULL) {
       first_free = refal.flhead->next;
       was_coll = lgcl();
       if (was_coll == 1) {
        p = refal.flhead->next;
        n = 0;
        while (( p != first_free) && ( n != 120)) {
         n++;
         p = p->next;
        }
        if (n == 120) return (1);
       }
      }
      new_block = malloc(101*sizeof(linkcb));
      work_var = malloc(250*sizeof(linkcb));
      if (new_block == NULL) return (0);
      if (work_var == NULL) return (0);

                         -30-


      free(work_var);
      new_block->prev = last_block;
      last_block = new_block;
      curr_size = curr_size + 100;
      rflist (new_block + 1, 100);
      return (1);
    }
      
    П о д п р о г р а м м а rftermm. 
    
  Назначение.
    Освобождает всю память, захваченную в результате обращения к
функции lincrm и терминирует Рефал-систему. 
  Обращение.
    rftermm();
  Параметры.
    Параметров нет.
  Использование.
    Освобождает всю память, захваченную в результате обращения к
функции lincrm и терминирует Рефал-систему, обратившись к  функ-
ции rfterm. 
  Исходный текст.
  
    #include "refal.def"
    
    extern linkcb *last_block;
    
    rftermm ()
     {
      linkcb *new_block;
      
      while (last_block != NULL) {
       new_block = last_block;
       last_block = new_block->prev;
       free(new_block);
      }
      rfterm();
      return;
     }
      
      
                   17. Вызов программы на Си из программ,
                             написанных на Рефале 

    Рефал-программа  может  вызвать процедуры, написанные на Си.
Вызываемая процедура с точки зрения Си должна быть либо програм-
мой  без  параметров,  либо  с одним параметром - адресом общего
блока refal. 
    Обращение к программе на Си делается следующим образом. 
    Пусть нужно вызвать Си-программу cproc. Тогда в Рефал-модуле
метку Cproc следует описать как внешнюю следующим образом: 

    extrn cproc

                         -31-

      
    После  этого,  как только станет ведущим функциональный терм
вида 
    k/cproc/ ex. 
    
    вызовется Си-процедура cproc 
    Если эта процедура ничего не изменяет в поле зрения  (напри-
мер,  если  она  не знает, что её вызвали из Рефал-программы),то
результатом замены будет "пусто". 
    Если же эта процедура написана в расчёте на то, что её будет
вызывать  Рефал-программа,  то  результатом замены будет то, что
она сформирует между звеньями,  на  которые  указывают  prevr  и
nextr из общего блока refal. 


                   18. Написание первичных функций на Си. 

    Всякая  первичная  функция, написанная на Си, представляет
собой подпрограмму с одним параметром, адресом блока refal. 
    В тот момент, когда процедура  на  Си  получает  управление,
вызвавший её процесс находится в состоянии 4, а его таблица сос-
тояния является текущей, т.е. её адрес находится в слове  currst
общего  блока  refal.  В словах preva и nexta общего блока refal
находятся адреса звеньев, между которыми находится аргумент фун-
кции,  т.е.  содержимое ведущего функционального терма (исключая
имя функции, стоящее сразу после "k"). 
    Если аргумент функции пуст, то выполнено 
    
      (refal.preva ->next == refal. nexta) &&
      (refal.nexta ->prev == refal. preva)
      
    В словах prevr и nextr общего блока refal  находятся  адреса
звеньев,  между которыми подпрограмма может сформировать резуль-
тат замены. В момент вызова подпрограммы результат замены  пуст,
т.е. выполнено 

      (refal.prevr ->next == refal. nextr) &&
      (refal.nextr ->prev == refal. prevr)
      
    Таким образом, если программа на Си не изменяет поле зрения,
результатом замены будет автоматическое "пусто". 
  Предупреждение.
    Подпрограмма на Си не должна изменять preva,  nexta,prevr  и
nextr,  а  также содержимое звеньев, на которые указывают prevr,
nextr и nexta, за исключением полей preva ->next, nexta  ->prev,
prevr  ->next  и  nextr  ->prev. Звенья, находящиеся между preva
(включительно) и nexta (исключительно), можно  использовать  для
формирования результата замены. 
    Поле  nextr  ->info.codep  содержит адрес знака ".", который
станет ведущим после окончания данного шага.  Первичная  функция
может  использовать эту информацию для порождения функциональных
скобок в результате замены. При этом нужно будет только надлежа-
щим образом скорректировать nextr ->info.codep .

                         -32-


    Слово upshot общего блока refal служит для того, чтобы сооб-
щить Рефал-системе, чем завершилась работа первичной функции. 
    * если при выходе из процедуры upshot=1, это  означает,  что
      шаг выполнен. 
    *  если  при  выходе upshot=2, это означает, что аргумент не
       принадлежит области определения первичной функции. 
    * если при выходе upshot=3, это означает, что список свобод-
ных  звеньев  содержит  недостаточное  количество звеньев, чтобы
можно было сформировать результат замены. 
    Перед вызовом первичной  функции  устанавливается  upshot=1,
поэтому  приходится  устанавливать  upshot только в тех случаях,
когда требуется присвоить ей значение 2 или 3. 
    Если в качестве аргумента первичной функции  допускаются  не
любые выражения, то, прежде чем что-либо изменять в поле зрения,
следует произвести синтаксический и семантический контроль аргу-
мента.  Если обнаружится, что аргумент не годится, следует уста-
новить upshot=2 и выйти из процедуры оператором return (или  пе-
редав управление на end). 
    Если  аргумент допустим, первичная функция начинает формиро-
вать результат замены, используя звенья из списка свободной  па-
мяти  и переставляя в результат замены куски списка из аргумента
(заключённые между nextr и nexta). 
    Может оказаться, что список свободной памяти содержит недос-
таточное количество звеньев и их не хватает для формирования ре-
зультата замены. в этом случае  следует  установить  upshot=3  и
выйти  из  процедуры  оператором return. После этого все звенья,
которые к этому моменту уже были вставлены между prevr  и  nextr
будут  возвращены в список свободной памяти, процесс остановится
в состоянии 3 и управление  вернётся  в  программу,  запустившую
данный  процесс  с помощью rfrun. Эта программа должна либо дать
дополнительную память под список, либо выполнить сборку  мусора,
либо  уничтожить  какие-либо  выражения  и освободившиеся звенья
присоединить к списку свободной памяти. после  этого  она  может
перезапустить процесс. 
  Предупреждение.
    При  формировании  результата  замены  можно брать звенья не
только из списка свободной памяти, но и  из  аргумента.  однако,
портить аргумент можно только тогда, когда первичная функция за-
ведомо знает, что она успешно сможет завершить шаг. Поэтому  ре-
комендуется  сначала взять все необходимые звенья из списка сво-
бодной памяти и переставить их в результат замены, либо убедить-
ся,  что  свободных  звеньев  заведомо хватает и уже после этого
что-то брать из аргумента. 
    Если первичная функция вставляет в  результат  замены  знаки
"k"  и  ".",  она может изменять nextr ->info.codep только после
того, как убедится, что шаг может быть успешно завершен. 
    В данной реализации описание первичной функции на Си  выгля-
дит следующим образом: 

                         -33-


     #include "refal.def"
     static cproc_ (refpt)
      REFAL *refpt;
      {
           <тело функции>
      }
     static char cproc_0[] = {'c ','p','r','o','c', '\005'};
     char cproc = '\122';
     static int (*cproc_1)() = cproc_;
    Вызов  Си-функции  оформляется как стандартная Рефал-функция
во внутреннем представлении (на языке сборки). Поэтому и необхо-
дима  описательная часть функции, расположенная в памяти в опре-
деленном порядке: 
    - имя функции (для Рефал-функций печати и отладчика), за ко-
      торым следует длина имени - представляется массивом симво-
      лов; 
    - код операции вызова Си-функции (восьмеричное 122). Эта пе-
      ременная  должна описываться как глобальная и быть эквива-
      лентна имени, указываемому в Рефал-программе  в  директиве
      extrn; 
    - указатель на Си-функцию (аргумент операции вызова Си-фун-
      кции); 
  Предупреждение.
    * Для обеспечения правильной работы интерпретатора и необхо-
      димо  использовать при компиляции Си-функций ключ выравни-
      вания указателей и целых на границу  байта,  чтобы  описа-
      тельная часть Си-функции размещалась в памяти непрерывно. 
    * Глобальной желательно делать только переменную,  описываю-
      щую код операции, чтобы не  плодить  в  объектных  модулях
      лишних описаний и избежать возможного дублирования имен. 
      

                   19. Примеры первичных функций на Си 
  
    П р и м е р 1. 
      
    Опишем  функцию, которая просматривает аргумент и заменяет в
нём все вхождения символа-литеры '+'  на  символ-литеру  '-'  на
всех  уровнях скобочной структуры. Эта функция может иметь, нап-
ример, следующее описание на Рефале. 
      
    cpfm '+'  ea = '-'           k/cpfm/ ea.
         sx   ea = sx            k/cpfm/ ea.
         (ex) ea = (k/cpfm/ ex.) k/cpfm/ ea.
         
    Описание на Си имеет вид: 
      
    #include "refal.def"
    static cpfm_ (refpt)
     REFAL *refpt;
    {
     linkcb *r;
     
     rftpl (refpt ->prevr, refpt ->preva, refpt ->nexta);

                         -34-


     r = refpt ->prevr ->next;
     while (r != refpt ->nextr) {
          if (r ->tag == TAGO &&
              r ->info.infoc == '+')
             r ->info.infoc = '-';
          r = r ->next;
     }
    }
    static char cpfm_0[] = {'c ','p','f','m','\004'};
    char cpfm = '\122';
    static int (*cpfm_1)() = cpfm_;
      
    П р и м е р 2. 
      
    Опишем на Си первичную функцию  crel,  обращение  к  которой
имеет вид 
     k/crel/ sx sy.,
    где  sx  и  sy - символы-литеры. Результатом замены является
выражение 
     sz sx sy,
    где sz = '<', если код sx меньше кода sy, sz = '=', если  sx
= sy и sz = '>', если код sx больше кода sy. 
      
    #include "refal.def"
    static crel_ (refpt)
     REFAL *refpt;
     {
      linkcb *px, *py, *pz;
      
      px = refpt->preva->next;
      if (px == refpt ->nexta) goto FAIL;
      py = px ->next;
      if (py == refpt ->nexta) goto FAIL;
      if (py ->next != refpt ->nexta ||
          px ->tag != TAGO ||
          py ->tag != TAGO) goto FAIL;
      if (!lins(refpt->prevr, 1)) goto LACK;
      pz = refpt ->prevr ->next;
      rftpl (pz, refpt ->preva, refpt ->nexta);
      pz ->info.codep = NULL;
      pz ->tag = TAGO;
      if (px ->info.infoc < py ->info.infoc)
         pz ->info.infoc = '<';
      else if (px ->info.infoc > py ->info.infoc)
              pz ->info.infoc = '>';
           else
              pz ->info.infoc = '=';
      goto DONE;
FAIL: refpt ->upshot = 2; goto DONE;
LACK: refpt ->upshot = 3; 
DONE:
     }

                         -35-


    static char crel_0[] = {'c ','r','e','l','\004'};
    char cproc = '\122';
    static int (*crel_1)() = crel_;
      
      
    П р и м е р 3. 
  
    Чтобы  разобраться  в  том, как программа, написанная на Си,
может порождать знаки "k"и "." в результате замены, опишем на Си
функцию, эквивалентную следующей Рефал-функции. 

   twokd ex '+' ey = k/func1/ ex. k/func2/ ey.
   
    Эта же функция описывается на Си. 
      
    #include "refal.def" 
    
    extern char func1, func2;
    
    static twokd_ (refpt) 
     REFAL *refpt; 
    { 
     linkcb *p, *pk1, *pf1, *pd1, *pk2, *pf2, *pd2;
     
     p = refpt->preva; 
     while (p ->tag != TAGO ||
            p ->info.infoc != '+') { 
          p = p ->next; 
          if (p == refpt ->nexta) { 
             refpt ->upshot = 2; 
             return;  
           }  
     }
     if (!lins (prevr, 6)) {
        refpt ->upshot = 3;
        return; 
     } 
     pk1 = refpt ->prevr ->next; 
     pf1 = pk1 ->next;  
     pd1 = pf1 ->next;  
     pk2 = pd1 ->next;  
     pf2 = pk2 ->next; 
     pd2 = pf2 ->next; 
     rftpl (pf1, refpt ->preva, p);  
     rftpl (pf2, p, refpt ->nexta);  
     pf1 ->info.codef = &func1;  
     pf1 ->tag = TAGF; 
     pf2 ->info.codef = &func2; 
     pf2 ->tag = TAGF; 
     pd1 ->info.codep = pk1;
     pd1 ->tag = TAGD; 
     pk1 ->info.codep = pd2; 
     pk1 ->tag = TAGK; 
     pd2 ->info.codep = pk2; 

                         -36-


     pd2 ->tag = TAGD; 
     pk2 ->info.codep = refpt ->nextr ->info.codep 
     refpt ->nextr ->info.codep = pd1; 
     refpt ->nextr ->tag = TAGK;  
    }  
    static char twokd_0[] = {'t','w','o','k','d', '\005'};  
    char twokd = '\122'; 
    static int (*twokd_1)() = twokd_; 
  
    П р и м е р 4. 
      
    Опишем функцию apply, обращение к которой из Рефал-программы
имеет вид: 
    k/apply/ ex.
    где ex - произвольное выражение. 
    Выполнение  этого терма происхожит соежующим образом. созда-
ется новое поле зрения и новая копилка. В поле хрения помещается
функциональный терм 
    k ex .
    а в новую копилку переносится содержимое старой копилки. 
    После этого делается попытка вычислить функциональный терм в
новом поле зрения. 
    Возможны три варианта завершения:  нормальный  останов  (N),
останов  "отождествление  невозможно"  (R) и осмтанов "свободная
память исчерпана" (S). 
    В случае N результатом замены будет выражение 
       'N' ey
    где ey - результат вычисления функционального терма 
        k ey .
    В случае R результатом замены будет выражение 
       'R' ey
    где ey - это содержимое того функционального терма, при выч-
мслении которого произошел останов. 
    В случае S результатом замены будет выражение 
       'S' 
    При  любом варианте содержимое новой копилки переносится об-
ратно в старую копилку. 
    Процедура описывается на Си следующим образом. 
      
    #include "refal.def"
    static appl_()
     {
      extern REFAL refal;
      st s_st, *upst;
      linkcb *px,*pk,*pd;
      
      upst = refal.currst;
      if (!lins(refal.prevr,1)) goto LACK;
      px = refal.prevr->next;
      if (!lcre(&s_st)) goto LACK;
      if (!lins(s_st.view,2)) {
        rfcanc(&s_st);
        goto LACK;
      }

                         -37-


      pk = s_st.view->next;
      pd = pk->next;
      pk->info.codep = NULL;
      pk->tag = TAGK;
      pd->info.codep = pk;
      pd->tag = TAGD;
      s_st.dot = pd;
      rftpl(pk,refal.preva,refal.nexta);
      rftpl(s_st.store,upst->store,upst->store);
      s_st.stop = -1;
      do {
          rfrun(&s_st);
          if (s_st.state == 3)
            if (lincrm()) s_st.state = 1;
      } while ((s_st.state == 1) && (s_st.dot != NULL));
      rftpl(upst->store,s_st.store,s_st.store);
      switch (s_st.state) {
        case 1:
              px->info.infoc = 'N';
              rftpl (px,s_st.view,s_st.view);
              break;
        case 2:
              px->info.infoc = 'R';
              pd = s_st.dot;
              pk = pd->info.codep;
              rftpl(px,pk,pd);
              break;
        case 3:
              px->info.infoc = 'S';
              break;
      }
      rfcanc(&s_st);
      return;
     LACK: refal.upshot = 3;
     }
    static char appl_0[] = { 'a','p','p','l','y','\005'};
    char apply = '\122';
    static char (*appl_1)() = appl_;
      
    П р и м е р 5. 
      
    Опишем на Си первичные функции для работы со статическими  и
динамическими ящиками. 
      
    /*  file xboxes: refal-functions: new,ptr,gtr,rdr,wtr.swr  */
    /* in current version name "ptr" replaced on "xptr"        */
    #include "refal.def"
    static new_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r;

                         -38-

      
      if (!lins(refpt->prevr,1)) {
         refpt->upshot = 3; return;}; /* LACK */
      r = refpt->prevr->next;
      r->info.codep = refpt->preva; r->tag = TAGR;
      p = refpt->nexta->prev;
      p->next = refpt->preva;
      refpt->preva->prev = p;
      refpt->nextr->next = refpt->nexta;
      refpt->nexta->prev = refpt->nextr;
      refpt->preva->info.codep = refpt->dvar;
      refpt->preva->tag = 0;
      refpt->dvar = refpt->preva;
     }
    static char new_0[] = {'n','e','w','\003'};
    char new = '\122';
    static char (*new_1)() = new_;
    
    static gtr_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r;
      int emp;
    
      emp = 1;
      if (!enter(refpt,emp,&p,&r)) {
         refpt->upshot = 2; return;}; /* FAIL */
      rftpl(refpt->prevr,p,p);
     }
    static char gtr_0[] = { 'g','t','r','\003'};
    char gtr ='\122';
    static (*gtr_1)() = gtr_;
    
    static rdr_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r;
      int emp;
    
      emp = 1;
      if (!enter(refpt,emp,&p,&r)) {
         refpt->upshot = 2; return;}; /* FAIL */
      if (!lcopy(refpt->prevr,p,p)) {
         refpt->upshot = 3; return;}; /* LACK */
     }
    static char rdr_0[] = {'r','d','r','\003'};
    char rdr = '\122';
    static (*rdr_1)() = rdr_;
    
    static ptr_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r,*q;
      int emp;

                         -39-


      emp = 0;
      if (!enter(refpt,emp,&p,&r)) {
         refpt->upshot = 2; return;}; /* FAIL */
      q = p->prev;
      rftpl(q,r,refpt->nexta);
     }
    static char ptr_0[] = {'p','t','r','\003'};
    char xptr = '\122';
    static (*ptr_1)() = ptr_;
    
    static wtr_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r;
      int emp;
    
      emp = 0;
      if (!enter(refpt,emp,&p,&r)) { 
         refpt->upshot = 2; return;}; /* FAIL */
      rfdel(p,p);
      rftpl(p,r,refpt->nexta);
     }
    static char wtr_0[] = {'w','t','r','\003'};
    char wtr = '\122';
    static (*wtr_1)() = wtr_;
    
    static swr_(refpt)
     REFAL *refpt;
     {
      linkcb *p,*r;
      int emp;
    
      emp = 0;
      if (!enter(refpt,emp,&p,&r)) {
         refpt->upshot = 2; return;}; /* FAIL */
      rftpl(refpt->prevr,p,p);
      rftpl(p,r,refpt->nexta);
     }
    static char swr_0[] = {'s','w','r','\003'};
    char swr = '\122';
    static (*swr_1)() = swr_;
     
    #define N_SWAP 0116
    
    static enter(refpt,emp,pp,rp)
     REFAL *refpt;
     int emp;
     linkcb **pp,**rp;
     {
      linkcb *p,*r;
      char *q;

                         -40-

    
      r = refpt->preva->next;
      if(r == refpt->nexta) return(0);
      if(emp && (r->next != refpt->nexta)) return(0);
      if(r->tag == TAGR) p = r->info.codep;
      else if (r->tag == TAGF) {
            q = r->info.codef;
            if( *q != N_SWAP ) return(0);
            q++;
            p = q;
            if((p->prev) == NULL) {
             p->prev = p->next = p;
             p->info.codep = refpt->svar;
             p->tag = 0;
             refpt->svar = p;
            };
           }
           else return (0);
      *pp = p;
      *rp = r;
      return(1);
     }
      
