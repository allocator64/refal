              
     4. Компиляция и исполнение РЕФАЛ-программ
     Компиляция, компоновка и исполнение РЕФАЛ-программ может 
производиться на IBM PC под управлением операционной системы 
MS DOS в тех ее версиях, в которых функционирует система 
Турбо-Си; на ЭВМ типа PDP-11 под управлением системы RT-11 
или ее производных, таких как TSX; на ЭВМ типа VAX-11 под 
управлением VMS. 
     Рефал-система представляет собой совокупность файлов:
     - исполняемый (загрузочный) модуль компилятора,
     - объектная библиотека,
     - объектные модули запускающих программ,
     - командные файлы,
     - демонстрационные(тестовые) программы.
     
     4.1. РЕФАЛ-система на IBM PC
     На IBM PC РЕФАЛ-система хранится в следующих файлах: 
     refal.exe - компилятор с рефала в виде абсолютного 
образа памяти; 
     reflib.olb - библиотека объектных модулей, которая 
содержит первичные функции, а также программы, обеспечивающие 
интерфейс рефала и Си; 
     mainrf.obj и rfdbg.obj - объектные модули запускающих 
программ; 
     c.bat, cd.bat, ca.bat - командные файлы для запуска 
рефал-компилятора; 
     tes1.ref, tes2.ref, tes3.ref, tes4.ref - 
демонстрационные файлы-тесты. 
     При работе с рефал-системой нужно обеспечить доступ к 
директориям, в которых находятся рефал-система и Турбо-Си. 
Для этого нужно указать соответствующие пути в файле 
autoexec.bat. 
     Пусть, например, Турбо-Си находится на диске С: в 
директории ТС, а рефал-система на диске D: в директории RF. 
Тогда перед началом работы с рефал-системой следует выполнить 
команду 
     
     path C:\TC;D:\RF;
     
     Проще всего включить эту команду в файл autoexec.bat, 
который находится на системном диске, с тем, чтобы она 
выполнялась автоматически всякий раз, когда загружается MS 
DOS. Если, например, в файле autoexec.bat команда path имела 
вид 
     
     path C:\;C:\UTIL;
     
,то для работы с рефал-системой ее надо дополнить:
     
     path C:\;C:\UTIL;C:\TC;D:\RF;
     
     4.2. Подготовка исходных текстов РЕФАЛ-программ
     Исходные тексты рефал-программ можно подготавливать с 
помощью любого редактора текстов. Файл с исходными 
рефал-программами должен иметь записи длиной не более 80 
литер. Тип файла (расширение у имени файла) должен быть REF. 
     Первоначальный текст может быть введен непосредственно с 
экрана при помощи команды 
     
     copy con имя_файла.ref
     
     Пример. Ввод текста с экрана в файл proba.ref:
     copy con proba.ref
     proba start
         entry func
         extrn print
     func  = k/f1/'Привет!'.
     f1 e1 = k/print/e1.
         end
     ^Z
     
     4.3. Компиляция РЕФАЛ-программ
     За один запуск рефал-компилятора обрабатывается один 
файл, где может быть один или несколько рефал-модулей. Для 
компиляции необходимо выдать следующую команду: 
     
     refal  имя_файла  список_опций
     
     Список опций либо пуст, либо имеет вид:
     
     (опция1,опция2,...,опцияК)
     
     ,где опцияI - имя опции, представляющее собой цепочку 
литер, не содержащую пробелов. Имена опций отделяются друг от 
друга запятыми, пробелы в списке опций недопустимы. 
     Список опций служит для установки режимов работы 
компилятора. Допускаются следующие имена опций. 
     nsource - запретить выдачу исходного текста 
рефал-программы. Если не задана эта опция, исходный текст 
программы выдается в файл имя_файла.lst. 
     fname - установить режим полных имен. Если эта опция 
задана, то ко всем внутренним именам модуля спереди 
приписывается имя модуля и вслед за ним - литера ":". 
Например, если MOD - имя модуля, а FUNC - имя функции, то все 
вхождения метки FUNC преобразуются в MOD:FUNC. Эти 
расширенные имена затем используются для управления 
прокруткой при отладочном исполнении программы. 
     assem - компиляция в текст на языке ассемблера. Если эта 
опция задана, то файл имя_файла.ref может содержать несколько 
рефал-модулей и результатом работы компилятора будет файл на 
языке ассемблера имя_файла.asm. Если опция не задана, то в 
файле имя_файла.ref может быть только один рефал-модуль и 
результатом работы компилятора будет объектный файл 
имя_модуля.obj. 
     nname - запретить вставки в код имен рефал-функций. Это 
приводит к некоторому уменьшению размера модуля, но не 
допускает применения средств отладки к этому модулю. 
     Имена опций могут сокращаться до двух букв.
     
     Пример 1.
     refal exmpl1
     
     Компилируется модуль из файла exmpl1.ref. Исходный текст 
модуля выдается в файл exmpl1.lst. Результат работы 
компилятора - файл exmpl1.obj. 
     
     Пример 2.
     refal exmpl2 (ns,as)
     
     Компилируются модули из файла exmpl2.ref. Листинг не 
выводится. Результат работы компилятора - файл exmpl2.asm. 
     На терминал выводится протокол работы компилятора, 
который содержит имя компилируемого модуля, его длину, длину 
файла-результата или сообщения об ошибках, если таковые 
обнаруживаются в процессе компиляции. 
     Кроме вышеупомянутых, во время работы РЕФАЛ-компилятора 
создаются еще два временных файла в рабочей директории: 
sysut1.$rf и sysut2.$rf. В конце работы компилятора эти файлы 
уничтожаются. При недостатке места на диске в процессе 
компиляции могут быть выданы диагностические сообщения об 
ошибках в работе с этими файлами. 
     Если в результате работы компилятора получен 
ассемблерный модуль (была задана опция "as"), то объектный 
модуль должен быть получен из него обычным вызовом ассемблера 
PC. 
     
     4.4. Исполнение РЕФАЛ-программ
     Исполнение готовой рефал-программы производится с 
помощью запускающей программы mainrf, реализованной на Си, 
причем рефал-программа вызывается из нее по имени FUNC. 
Полученный после компиляции объектный модуль рефал-программы 
должен быть скомпонован с файлом mainrf.obj при помощи 
компоновщика Турбо-Си: 
     
    tlink mainrf имя_файла c:\tc\lib\c0l,имя_файла,NUL,reflib c:\tc\lib\cl
                                                  
     Здесь c0l.obj и cl.lib - файлы из директории Турбо-Си.
     Команда tlink создает исполняемый файл имя_файла.exe.
     После вызова этого исполняемого файла начинает работать 
программа mainrf, которая формирует начальное поле зрения 
вида <FUNC> и запускает рефал-машину. 
     Допустим, что требуется запустить рефал-машину начиная с 
входной точки JOB. Тогда в рефал-программе должно быть 
предложение вида 
     
     FUNC = <JOB>
         
     Команды компиляции, компоновки и запуска собраны в 
командном файле c.bat : 
     
     @refal %1 (ns)
     @tlink mainrf %1 c:\tc\lib\c0l,%1,NUL,reflib c:\tc\lib\cl
     @erase %1.obj
     @%1
     
     Имя рефал-программы является параметром при вызове этого 
командного файла: 
     
     c имя_программы
     
     Необходимые изменения в этот файл (другая директория для 
Турбо-Си, другой список опций) вносятся при помощи обычного 
редактора. 
     Если необходимо получить ассемблерный текст или 
откомпилировать несколько модулей в одном файле, вызывается 
командный файл ca.bat : 
     
     @refal %1 (ns,as)
     @c:\masm\masm %1,,NUL,NUL
     @tlink mainrf %1 c:\tc\lib\c0l,%1,NUL,reflib c:\tc\lib\cl
     @erase %1.obj
     @%1
     
     4.5. Средства отладки
     4.5.1. Вызов подпрограммы отладки
     Подпрограмма mainrf не содержит средств отладки. Ею 
следует пользоваться для запуска уже отлаженных 
рефал-программ. При отладке программ следует производить 
компоновку не с модулем mainrf.obj , а с модулем rfdbg.obj, 
исполняя команду 
     
    tlink rfdbg имя_файла c:\tc\lib\c0l,имя_файла,NUL,reflib c:\tc\lib\cl

     Команды компиляции, компоновки и запуска для отладки 
собраны в командном файле cd.bat : 
     
     @refal %1 (ns)
     @tlink rfdbg %1 c:\tc\lib\c0l,%1,NUL,reflib c:\tc\lib\cl
     @erase %1.obj
     @%1
     
    Здесь после вызова исполняемого файла начинает работать 
программа rfdbg. Она выдает приглашения, в ответ на которые 
пользователь должен задать управляющую информацию. Затем 
rfdbg анализирует полученную информацию. Если при этом 
обнаруживаются ошибки, работа rfdbg заканчивается. Если же 
ошибок нет, начинается исполнение рефал-программы. 
     Выдается 11 приглашений:
     
     > (function list):
     >= (function list):
     = (function list):
     != (function list):
     < (function list):
     <= (function list):
     TRAP (function list):
     STOP (step number):
     FROM (step number):
     TO (step number):
     E1= (y/n):
     
     Вся управляющая информация, задаваемая в ответ на эти 
приглашения, делится на две группы: 
     - управление остановом и 
     - управление прокруткой.
     Вся она имеет один из двух форматов:
     N            ( число шагов)
     F1 F2 ... FK ( список имен функций). 
     Обратите внимание, что список имен функций задается 
через пробел, а не через запятую. 
     
     4.5.2. Управление остановом
     В отладчике рефал-системы имеются средства управления 
остановом двух типов: STOP-условия, которые позволяют 
задавать останов по номеру шага, и TRAP-условия, которые 
позволяют задавать останов по имени функции. 
     Если в ответ на приглашение:
     
     STOP (step number):
     
     ввести целое число N, то работа рефал-программы 
остановится, как только будет выполнено N шагов. Например, 
если задано 
     
     STOP (step number):   30000
     
,то рефал-программа остановится перед началом выполнения шага 
30001. 
     Эта возможность полезна в тех случаях, когда 
отлаживаемая программа зацикливается. 
     Если в ответ на приглашение
     
     TRAP (function list):
     
     ввести список имен функций
     
     F1 F2 ... FN
     
,то это будет означать, что когда ведущим станет 
функциональный терм вида 
     
     <FI Ee>
     
,рефал-программа остановится, не приступая к выполнению 
очередного шага. Здесь FI - функция, объявленная ловушкой, а 
Ee - объектное выражение. 
     Эта возможность полезна в тех случаях, когда требуется 
выдать состояние поля зрения, копилки и ящиков в момент 
обращения к одной из функций-ловушек. При этом под именем 
функции подразумевается то имя, которое она имеет внутри того 
модуля, в котором она описана. 
     Если TRAP-условие задано вместе со STOP-условием, 
останов произойдет как только будет удовлетворено хотя бы 
одно из условий. 
     
     4.5.3. Управление прокруткой
     Прокрутка - выдача протокола о ходе выполнения 
рефал-программы - дает возможность получать информацию о 
выполнении отдельных шагов рефал-машины, а также об 
обращениях к указанным функциям и о результатах этих 
обращений. 
     При выдаче информации об отдельном шаге указываются 
     - номер шага, 
     - ведущий функциональный терм, 
     - результат выполнения шага.
     При выдаче информации об обращениях к заданным функциям 
указывается 
     - номер шага, на котором произошло обращение;
     - ведущий терм;
     - номер шага, на котором завершилось полное вычисление 
обращения к функции; 
     - окончательный результат замены, т.е. то выражение, 
которое получается, когда в выражении, возникшем из обращения 
к функции, не осталось ни одного функционального терма. 
     Задание на прокрутку может быть двух видов:
     - задание диапазона прокрутки;
     - задание условий прокрутки.
     Диапазон прокрутки задается с помощью приглашений
     
     FROM (step number):
     TO (step number):
     
,в ответ на которые нужно ввести целые числа Nf и Nt.
     Задание диапазона означает, что следует выдавать 
информацию только о тех шагах, номера которых лежат в 
интервале от Nf до Nt. Выдача информации о тех шагах, номера 
которых меньше Nf или больше Nt - запрещена. В частности, 
если Nf>Nt, то никакая информация выдаваться не будет. 
     Если Nf не задавать, но задать Nt, или хотя бы одно 
условие прокрутки, то считается, что Nf=1. 
     Если же задание "TO" не установлено, но определено 
задание "FROM" или хотя бы одно условие прокрутки, то 
считается, что Nt=2147483647, т.е. практически 
"бесконечности". 
     Таким образом, получается, что если диапазон прокрутки 
не задан, но задано хотя бы одно условие прокрутки, то Nf=1 и 
Nt=2147483647. 
     Если диапазон прокрутки не пуст, и не задано ни одного 
условия прокрутки, то считается, что следует выдавать 
информацию обо всех шагах, лежащих в этом диапазоне. 
     Приведем примеры заданий на прокрутку, состоящих только 
из указания диапазона. 
     
     Пример 1.
     FROM (step number):  1
     
     Печатается информация обо всех шагах.
     
     Пример 2.
     FROM (step number):  1000
     
     Печатается информация обо всех шагах, начиная с шага 1000.
     
     Пример 3.
     TO (step number):  5000
     
     Печатается информация обо всех шагах, начиная с шага 1 
до шага 5000 включительно. 
     
     Пример 4.
     FROM (step number):  500
     TO (step number):  600
     
     Печатается информация обо всех шагах, начиная с шага 500 
до шага 600 включительно. 
     Теперь рассмотрим, как задаются  условия прокрутки.
     В то время как диапазон прокрутки накладывает 
ограничения на номера шагов, для которых должна выдаваться 
информация, условия прокрутки указывают, какую именно 
информацию и о каких функциях следует выдавать. 
     Условия прокрутки задаются в ответ на приглашения
     
     > (function list):
     >= (function list):
     = (function list):
     != (function list):
     < (function list):
     <= (function list):
     
в виде списка функций F1 F2 ... FN. Список функций, в 
частности, может быть пустым. Под именем функции 
подразумевается то имя, которое она имеет внутри того модуля, 
в котором она описана, имена функций в списке функций 
разделяются пробелом. 
     Смысл управляющей информации:
     ">" - выдавать информацию о каждом шаге, начиная с 
момента обращения к заданной функции и до полного завершения 
ее исполнения, включая информацию об исполнении всех функций, 
которые она вызывает; 
     ">=" - то же, что для ">", плюс информация о поле 
зрения, сформированном в результате работы заданной функции; 
     "=" - выдавать информацию о том шаге, на котором 
происходит обращение к заданной функции; 
     "!=" - не выдавать информацию о том шаге, на котором 
происходит обращение к заданной функции; 
     "<" - не выдавать информацию о работе заданной функции ; 
     "<=" - информацию о работе заданной функции не выдавать, 
но выдать обращение к этой функции и сформированное ею поле 
зрения. 
     Каждое условие может задаваться независимо от всех 
других, но при этом надо учитывать ситуации, которые 
возникают из-за перекрестного обращения функций друг к другу. 
Например: 
     
     > (function list): FUNC1 FUNC2
     >= (function list): FUNC
     = (function list): PSI FI
     != (function list): FI EPS
     < (function list): XXX
     <= (function list): YYY
     
     Если в приведенном примере FUNC1 вызывает XXX и YYY, то 
будет выдаваться информация о работе FUNC1 и обо всех 
вызываемых ею функцций, исключая XXX и YYY, причем об XXX 
информации не будет никакой, а для YYY будет выдан шаг 
обращения к ней и сформированное ею поле зрения. 
     В общем случае условия прокрутки следующим образом 
истолковываются в процессе исполнения рефал-программы. 
     Управление прокруткой может находиться в одном из трех 
состояний: S1, S2 или S3. Оно может переходить из состояния 
S1 в состояние S2 и обратно, а также из состояния S2 в 
состояние S3 и обратно. Непосредственный переход из S1 в S3 
или из S3 в S1 - невозможен. 
     Переходами между состояниями S1 и S2 управляют условия 
">" и ">=". Переходами между состояниями S2 и S3 управляют 
условия "<" и "<=". Условия "=" и "!=" управляют выдачей 
информации в состоянии S2. Таким образом, получается схема 
переходов, изображенная на рис... 
     
                         =,!=
     ------   >,>=      ------   <,<=     ------
     I    I  ------>    I    I  ------>   I    I
     I S1 I             I S2 I            I S3 I
     I    I  <------    I    I  <------   I    I
     ------             ------            ------
     Рис...  Схема переходов между состояниями прокрутки.
     
     В начале работы прокрутка находится в состоянии S1. 
     Находясь в состоянии S1, прокрутка выполняет 
рефал-программу до тех пор, пока не встретится обращение к 
функции, для которой было задано одно из условий ">" или 
">=". Тогда прокрутка переходит в состояние S2, причем, если 
задано ">=", но не задано ">", то выдается обращение к этой 
функции. 
     Возврат в состояние S1 происходит только после того, как 
полностью закончится вычисление обращения к функции, по 
которому произошел переход из S1 в S2. При этом, если для 
этой функции было задано ">=", но не задано ">", то при 
возврате в S1 выдается окончательный результат замены, т.е. 
то выражение, которое возникло в результате полного 
вычисления обращения к функции. 
     Находясь в состоянии S2, прокрутка выполняет 
рефал-программу до тех пор, пока не встретится обращение к 
функции, для которой было задано условие "<" или "<=". Тогда 
прокрутка переходит в состояние S3, причем, если задано "<=", 
то выдается обращение к этой функции. 
     Возврат в состояние S2 из состояния S3 происходит только 
после того, как полностью закончится вычисление обращения к 
функции, по которому произошел переход в S3 из S2. При этом, 
если для этой функции было задано "<=", но не задано "<", то 
при возврате в S2 выдается окончательный результат замены, 
т.е. то выражение, которое возникло в результате полного 
вычисления обращения к функции. 
     Если прокрутка находится в состоянии S2, и для текущей 
функции не задано ни "<", ни "<=", то прокрутка выполняет 
один шаг и остается в состоянии S2. При этом, если для 
текущей функции задано условие "=", то выдается обращение к 
функции и результат непосредственной замены (результат 
выполнения шага). 
     
     Например, если заданы условия
     >= X
     =  Y1 Y2 Y3
     <= Z1 Z2
     
,то выдача будет начинаться при каждом обращении к функции X. 
Будет выдаваться обращение к X и результат ее полного 
вычисления. В процессе вычисления X будут выдаваться 
обращения к Y1, Y2, Y3 и непосредственно результаты замены, а 
также обращения к Z1 и Z2 и результат полного вычисления этих 
обращений. 
     Иногда требуется, чтобы выдавались только обращения к 
указанным функциям и окончательные результаты замены. Этого 
можно добиться, задав для них условия "=" и "<=". 
     Если задать только условие "<=", то будет выдаваться 
информация о всей программе, а о заданных функциях - только 
обращение к ним и результат их работы. 
     И, наконец, в тех случаях, когда требуется запустить 
прокрутку по всем функциям, с первого шага до последнего, 
можно задать условие "!=" для несуществующей функции. 
     
     4.5.4. Перехват останова по неотождествлению
     Легкость отладки рефал-программ в значительной степени 
обусловлена тем, что различные нарушения в структуре 
обрабатываемых объектов, как правило, довольно быстро 
приводят к авосту "отождествление невозможно". Однако это 
приятное свойство утрачивается, если какие-либо функции, 
написанные на Си, не проверяют правильность аргумента. 
Поэтому при отладке функций, написанных на Си, необходимо 
тщательно тестировать как те случаи, когда обращение к 
функции имеет допустимый вид, так и те случаи, когда аргумент 
функции задан неверно. Всегда, когда аргумент не принадлежит 
к областм определения функции, эта функция должна 
вырабатывать авост "отождествление невозможно". 
     Таким образом, всякий тест, предназначенный для проверки 
функций, написанных на Си, должен включать как правильные, 
так и заведомо неправильные обращения к этим функциям. 
     Для прогона таких тестов предусмотрен особый режим 
"E1=(y/n)". Если рефал-программа исполняется в этом режиме, 
то при возникновении состояния "отождествление невозможно" 
выполнение рефал-программы не прекращается. Вместо этого 
выдается номер текущего шага, предупреждающее сообшение и 
ведущий функциональный терм. Затем ведущий терм заменяется на 
пустое выражение и работа рефал-программы продолжается. 
     Таким образом, рефал-программа исполняется так, словно в 
конце каждой функции добавлено предложение 
     
     E1 =  
     
     Этому обстоятельству режим "E1=" и обязан своим 
названием. 
     Для того, чтобы рефал-программа исполнялась в режиме 
"E1=", необходимо в ответ на приглашение 
     
     E1=(y/n):
     
     ответить "y".
