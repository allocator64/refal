
      Система программирования РЕФАЛ-2 для ПЭВМ IBM PC.
                Описание библиотеки функций.


                    С О Д Е Р Ж А Н И Е


    Введение
 1. Функции ввода-вывода
 2. Функции арифметики
 3. Функции лексического анализа
 4. Функции для работы с символьными файлами
 5. Функция порождения процесса
 6. Функции для работы с символами-метками
 7. Функции для работы с копилкой
 8. Функции для работы со статическими и динамическими ящиками
 9. Описание функций


                         Введение

    В  этом документе описана библиотека функций, поставляе-
мая с системой программирования РЕФАЛ-2 для ПЭВМ IBM PC.
    Чтобы использовать любую из этих  функций  в  программе,
написанной на РЕФАЛе, необходимо об'явить ее внешней в соот-
ветствующем модуле с помощью директивы  extrn .
    Часть библиотечных функций написана на  РЕФАЛе  и  затем
скомпилирована в об'ектные модули с помощью РЕФАЛ-компилято-
ра. Остальные функции реализованы на языке Си.  Эти  функции
называются   м а ш и н н ы м и   о п е р а ц и я м и .
    С  точки  зрения пользователя РЕФАЛ-системы единственное
отличие машинных операций от обычных функций, написанных  на
РЕФАЛе,  состоит  в  том, что обращения к машинным операциям
всегда полностью вычисляются за один шаг РЕФАЛ-машины (неза-
висимо  от  того, насколько длинная и сложная последователь-
ность действий при этом выполняется) , а также  в  том,  что
при  выполнении  этих обращений может возникать побочный эф-
фект. Например, с помощью машинных операций реализуются опе-
рации  ввода-вывода. Кроме того, некоторые машинные операции
могут менять состояние рефал-машины .


                  1. Функции ввода-вывода

    Функции ввода-вывода предназначены для организации прос-
тейшего  диалогового  взаимодействия  между  пользователем и
программой.
    Для ввода строки с клавиатуры используется машинная опе-
рация card. Для вывода информации на экран предназначены ма-
шинные операции print, prout, printm, proutm, которые разли-
чаются  возвращаемым  значением и способом представления ин-
формации на экране.
    Ввод-вывод  может  быть переназначен в произвольный файл
стандартным образом.


                   2. Функции арифметики

    Функции арифметики работают с целыми числами. Целое чис-
ло - это макроцифра,  которой  может  предшествовать  символ
знака. Примерами целых чисел являются:

                         '+' /14/
                             /545/
                         '-' /8/
                             /0/

    Целое  число  нуль представляется либо нулевой макроциф-
рой, либо пустым выражением.
    Все функции арифметики допускают  использование  пустого
выражения в качестве аргумента и воспринимают его как нуль.
    К функциям арифметики относятся:
    - add (сложение);
    - mul (умножение);
    - sub (вычитание);
    - dr (деление нацело с остатком);
    - div (деление нацело);
    - p1 (прибавление единицы);
    - m1 (вычитание единицы).
    Для преобразования целых чисел в символьный вид и обрат-
но используются функции symb и numb.


              3. Функции лексического анализа

    Стандартная  библиотека  РЕФАЛа/2  содержит ряд функций,
полезных при выполнении лексического анализа в трансляторах,
системах  естественноязыкового общения, языковых конверторах
и т.п. системах. Такими функциями являются:
    - first - предназначена для отщепления от начала выраже-
              ния части, имеющей указанную длину;
    - last -  предназначена для отщепления от конца  выраже-
              ния части, имеющей указанную длину;
    - lengw - вычисляет длину аргумента, измеренную  в  тер-
              мах,  т.е.  количество термов нулевого уровня,
              составляющих аргумент;
    - lengr - вычисляет реальную длину аргумента, т.е. коли-
              чество  символов  и скобок, составляющих аргу-
              мент;
    - multe - копирует (размножает) аргумент в заданном  ко-
              личестве экземпляров;
    -  type - предназначена для распознавания типа терма, с
              которого начинается выражение.


        4. Функции для работы с символьными файлами

    Описываемые в этом разделе функции позволяют работать не
более  чем  с  двумя  файлами одновременно. При этом один из
этих файлов доступен только на чтение (и  именуется  "файлом
чтения"),  а другой файл - доступен только на запись (и име-
нуется "файлом записи").
    Работа  с  файлом чтения производится с помощью машинных
операций libget, opnget и clsget.  Открывает  файл  машинная
операция  opnget , закрывает - clsget , чтение выполняется с
помощью libget .
    Файл записи открывается машинной операцией  opnput , за-
пись в него выполняет  libput , закрывает -  clsput .


              5. Функция порождения процесса

    Функция apply позволяет писать программы,  анализирующие
аварийные  ситуации  типа  "отождествление  невозможно"  или
"свободная память  исчерпана"  и  предпринимающие  некоторые
дальнейшие действия по обработке таких ситуаций.
    Функция  apply  порождает  новое поле зрения, помещает в
него функциональный терм, определенный в ее аргументе, и пы-
тается вычислить его. Результат такой попытки возвращается в
то поле зрения, из которого была вызвана apply.
    После того, как результат замены  сформирован,  дополни-
тельное  поле  зрения,  созданное  в  результате обращения к
apply , уничтожается.
    Можно обращаться к  apply  рекурсивно. В этом случае об-
разуется стек из полей зрения.


         6. Функции для работы с символами-метками

    В некоторых случаях возникает  необходимость  превратить
цепочку  символов  в символ-метку или, наоборот, получить из
символа-метки цепочку символов,  составляющих его тело.  На-
пример, из цепочки символов 'ABCDE' построить символ /ABCDE/
или символ-метку /label/ превратить в цепочку  'label'.  При
этом  должно выполняться следующее требование: если мы будем
превращать одну и ту же цепочку символов в символ-метку нес-
колько раз, то все созданные символы-метки должны быть равны
друг другу, т.е. являться экземплярами одного и того же сим-
вола.
    Для создания символов-меток и обратного превращения их в
цепочки об'ектных символов используются  функции  ftochar  и
chartof:
    - ftochar - превращает  символ-метку в цепочку символов,
                которая является телом символа-метки;
    - chartof - превращает цепочку символов в  символ-метку,
                имеющий  тело, совпадающее с заданной цепоч-
                кой символов, при этом одна и та же  цепочка
                символов  превращается  в один и тот же сим-
                вол-метку, т.е. не создается новый экземпляр
                символа-метки. Это достигается за счет того,
                что функция создает и  поддерживает  таблицу
                символов-меток,  порожденных  ею  из цепочек
                символов.
    Функция  functab регистрирует в таблице символов, созда-
ваемой функцией chartof, указанный символ-метку. Это  требу-
ется  делать, если необходимо, чтобы символ-метка, создавае-
мый из цепочки символов, заведомо совпадал  с  символом-мет-
кой, определенным в рефал-программе.


             7. Функции для работы с копилкой

    До  сих пор мы считали, что РЕФАЛ-машина имеет два запо-
минающих устройства: поле памяти и поле зрения.  В  действи-
тельности  у  нее имеется еще одно запоминающее устройство -
копилка, доступ к которому возможен с  помощью  функций  br,
dg, cp, rp, dgall.
    Имена этих функций имеют следующий смысл: br -  закопать
(bury), dg - выкопать (dig out), cp - скопировать (copy), rp
- заменить (replace).
    Содержимое копилки всегда имеет следующий вид:

          ([X1]'='[Y1]) ([X2]'='[Y2]) ... ([XN]'='[YN])

    где [X1], [X2], ..., [XN] и [Y1], [Y2], ..., [YN] - про-
извольные  об'ектные  выражения. Смысл содержимого копилки -
следующий. [ХI] - есть имя выражения [YI] .
    Перед началом работы программы копилка  содержит  пустое
выражение.
    Функции br, dg, rp, cp и dgall предназначены для переме-
щения выражений из поля зрения в копилку и обратно (см. опи-
сание функций).


         8. Функции для работы со статическими и
                   динамическими ящиками

    Об'ектами  обработки для программ, написанных на РЕФАЛе,
являются выражения. Выражение представляет собой по существу
способ  представления древовидных структур в виде одномерных
цепочек символов и скобок.
    При решении некоторых задач,  однако,  оказывается,  что
требуется  обрабатывать  структуры  данных, которые сложнее,
чем древовидные.
    Конечно, в принципе, любые конструктивные об'екты  можно
представить  в виде деревьев, однако это не всегда удобно, а
иногда приводит к существенному замедлению работы  программы
(в  тех случаях, когда прямой доступ к данным приходится мо-
делировать с помощью ассоциативных поисков).
    Средством РЕФАЛа-2, дающим возможность обрабатывать про-
извольные графы, являются  с т а т и ч е с к и е  и  д и -
н а м и ч е с к и е  я щ и к и.
    До сих пор предполагалось, что РЕФАЛ-машина  состоит  из
трех запоминающих устройств: поля памяти, в котором находит-
ся набор предложений, поля зрения и  копилки.  Теперь  будем
считать,  что имеется еще потенциально бесконечное множество
запоминающих устройств, называемых   я щ и к а м и.   Каждый
ящик  содержит произвольное об'ектное выражение, которое мо-
жет изменяться в процессе работы. Это выражение мы будем на-
зывать  с о д е р ж и м ы м  ящика.
    Каждому  ящику  соответствует функция, с помощью которой
можно получить доступ к содержимому ящика.  Эти  функции  мы
будем называть   о б м е н н ы м и.
    Таким  образом, имеется взаимно-однозначное соответствие
между множеством обменных функций и множеством  ящиков.  Об-
менная  функция, соответствующая некоторому ящику, будет на-
зываться также   и м е н е м   этого ящика.
    Наглядно взаимосвязь между ящиком  и  обменной  функцией
можно изобразить следующим образом.

                            ---------
                     FUNC : |  [E]  |
                            ---------

    где  "FUNC"  -  имя обменной функции, а [E] - содержимое
ящика.
    Обменные функции работают следующим образом.  После  вы-
числения терма

                       k/FUNC/ [E'].

    где  "FUNC" - имя ящика, в поле зрения останется выраже-
ние [E] - содержимое ящика с именем "FUNC", а выражение [E']
станет содержимым ящика. Таким образом, происходит обмен ин-
формацией между полем зрения и ящиком  (откуда  и  произошло
название обменных функций).
    Все ящики делятся на   с т а т и ч е с к и е   и   д и -
н а м и ч е с к и е.  Статические ящики существуют в течение
всего времени выполнения программы и не могут ни  порождать-
ся,  ни уничтожаться во время работы. Напротив, динамические
ящики порождаются только во время работы и могут уничтожать-
ся.
    Все   с т а т и ч е с к и е  ящики должны быть описаны в
программе. Для этого используются директивы "SWAP",  которые
выглядят следующим образом:

           SWAP   [идент1],[идент2],...,[идентN]

    Т.е., пропустив один или несколько пробелов, следует за-
писать ключевое слово "SWAP", затем пропустить один или нес-
колько  пробелов  и перечислить через запятую имена обменных
функций.
    Таким образом, статические ящики описываются одновремен-
но со своими обменными функциями. Перед началом работы прог-
раммы все статические ящики содержат пустые выражения.

    П р и м е р. Рассмотрим следующий фрагмент программы:

         SWAP  X1,X2
 SWX1X2   = k/X1/ 'A'. k/X2/ 'B'. k/SW2/ /X1/ /X2/.
 SW2      SX SY = k SX k SY k SX...

   В процессе вычисления обращения

                        k/SWX1X2/.

    в ящики "X1" и "X2" сначала занесутся символы 'A' и  'B'
соответственно. Затем, в результате вычисления терма
                     k/SW2/ /X1/ /X2/.
    содержимые  ящиков  поменяются  местами. То есть в ящике
"X1" окажется символ 'B' , в ящике "X2" - символ 'A' ,  а  в
поле зрения останется пустой результат замены.
    Д и н а м и ч е с к и е ящики порождаются в процессе ра-
боты программы первичной функцией "new" (см. описание).
    Имена динамических ящиков являются символами особого ти-
па - символами-ссылками. В отличие от имен статических  ящи-
ков,  являющихся  обычными символами-метками, символы-ссылки
нельзя употреблять в виде констант в  рефал-программах.  Тем
не менее, при отладке рефал-программ возникает необходимость
как-то печатать символы-ссылки. Они печатаются в виде

                        /%FFFFFFFF/

    где "FFFFFFFF" - восемь шестнадцатеричных цифр, обладаю-
щих следующими свойствами:
     - в   каждый   момент    работы   программы   различным
        символам-ссылкам соответствуют различные "FFFFFF"
     - один  и  тот же  символ-ссылка  имеет  одно и  то  же
        "FFFFFFFF" на протяжении одного запуска программы
    Эти  свойства  выполняются  в  силу того, что "FFFFFFFF"
представляет собой адрес места, в котором расположен динами-
ческий ящик в памяти машины.

    П р и м е р.    Рассмотрим следующий фрагмент программы,
аналогичный приведенному в предыдущем примере.
         EXTRN NEW
 SWR1R2   = k/SW2/ k/NEW/ 'A'. k/NEW/ 'B'..
 SW2      SX SY = k SX k SY k SX...
    Теперь, в результате вычисления терма "k/SWR1R2/." будут
выполнены  два  обращения к функции "NEW". В результате чего
образуются два ящика, которые могут иметь, например, следую-
щие имена: "/%07061300/" и "/%05302400/". Ящик "/%07061300/"
будет содержать символ 'A', а ящик  "/%05302400/"  -  символ
'B'.  Затем  функция "SW2" воспользуется символами-ссылками,
оставшимися в поле зрения,  и  поменяет  местами  содержимое
этих ящиков.
    Обратите внимание на следующий факт: обращение к функции
"SWR1R2" привело к появлению двух новых ящиков. Можно ли те-
перь  как-нибудь  извлечь  содержимое этих ящиков? Очевидно,
что нельзя. Ни в поле зрения, ни в копилке, ни в других ящи-
ках  не сохранилось имен этих ящиков. Поэтому дальнейшая ра-
бота программы не изменится, если эти ящики уничтожить.  Это
делается в Рефале с помощью встроенного механизма сборки му-
сора, автоматически запускающегося в случае исчерпания  сво-
бодной списковой памяти.
    Библиотека  функций  содержит, помимо new, еще пять пер-
вичных функций для работы с ящиками, которые, хотя и не дают
ничего  принципиально  нового,  часто  оказываются удобными:
gtr, rdr, wtr, ptr, swr .


                    9. Описание функций

    Данный раздел содержит описания функций, расположенных в
алфавитном порядке. Для каждой функции приводится  описание,
формат  вызова (передаваемые аргументы), возвращаемое значе-
ние, пример вызова функции в  формате

    <вызов функции> --> <результат замены>

с описанием побочных эффектов  и список функций, относящихся
к той же группе, что и описываемая функция.




                   Ф у н к ц и я     add
                   ---------------------


ВЫЗОВ :           k/add/ ([N1]) [N2] .

               где [N1] и [N2] - целые числа (может быть -
               пустые).

ОПИСАНИЕ :     Функция add предназначена для сложения двух
               целых чисел [N1] и [N2] .

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ     : Результатом вызова функции add является целое
               число. Если результат положителен - знак '+'
               не ставитcя.


ПРИМЕРЫ :      k/add/ (/1/) /2/ .     -->     /3/

               k/add/ (   ) /2/ .     -->     /2/

СМ.ТАКЖЕ :     sub , mul , dr , div , p1 , m1 .




                  Ф у н к ц и я   apply
                  ---------------------


ВЫЗОВ :                 k/apply/ [E] .

               где [E] - произвольное выражение.

ОПИСАНИЕ :        Выполнение этого вызова происходит следу-
               ющим образом. Создается новое поле зрения, в
               которое помещается функциональный терм
                         k/[E]/ .
                   После этого делается попытка вычислить
               этот функциональный терм. Возможны три исхода
               этой попытки: нормальный останов, останов
               "отождествление невозможно" и останов "сво-
               бодная память исчерпана".
                   Затем формируется соответствующий резуль-
               тат замены (возвращаемое значение) и дополни-
               тельное поле зрения, созданное в результате
               обращения к apply, уничтожается.
                   Можно обращаться к apply рекурсивно. В
               этом случае образуется стек из полей зрения.


ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ     :     В случае нормального останова результатом
               замены будет выражение

                         'N' [E1]

                   где [E1] - результат вычисления терма
               k/[E]/ . .
                   В случае останова "отождествление невоз-
               можно" результатом замены будет выражение

                         'R' [E1]

                   где [E1] - содержимое того функционально-
               го терма вида k/[E1]/. , попытка вычисления
               которого привела к останову.
                   В случае останова "свободная память ис-
               черпана" результатом замены будет выражение

                            'S'


ПРИМЕР :       Пусть в поле памяти имеется функция

                    rev  s1 s2  = s2 s1

               Тогда

                    k/apply/ /rev/ 'ab'.  --> 'N' 'ba'

                    k/apply/ /rev/ 'abc'. --> 'R' /rev/'abc'


                     Ф у н к ц и я  br
                     -----------------


ВЫЗОВ :        k/br/ [X] '=' [Y].

               где [X] и [Y] - произвольные об'ектные  выра-
               жения.

ОПИСАНИЕ :         При обращении к функции  br  терм  "([Х]
               '='  [Y])"  добавляется к копилке слева, т.е.
               копилка преобразуется следующим образом:

                [E]  -->  ([Х] '=' [Y]) [E]

               где  [E]  - содержимое копилки до обращения к
               br. Результат обращения к br - пусто.
                    Можно закапывать несколько выражений под
               одним и тем же именем.


ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :           В результате выполнения

                 k/br/ 'X=A'. k/br/ 'X=B'.

                    копилка преобразуется следующим образом:

               [E]  -->  ('X=B')('X=A') [E]


СМ.ТАКЖЕ :     dg , dgall , cp , rp .



                  Ф у н к ц и я   card
                  --------------------

ВЫЗОВ :        k/card/ .

ОПИСАНИЕ :     Машинная операция  card  дает возможность чи-
               тать записи из стандартного входного  потока.
               Обычно в качестве входного потока назначается
               ввод с клавиатуры, но он может быть  переназ-
               начен  в  файл  при запуске программы (в этом
               случае необходимо  следить  за  соответствием
               количества вызовов функции  card  и количест-
               ва записей в файле, если записей меньше,  чем
               вызовов,  возможны  непредсказуемые результа-
               ты).

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     После вызова функции card программа переходит
               в состояние ожидания ввода строки. По оконча-
               нии ввода необходимо нажать  клавишу  "Ввод".
               Введенная строка и является возвращаемым зна-
               чением.

ПРИМЕР :       k/card/.
                        -->

                       'эта  строка  введена  с  клавиатуры'

СМ.ТАКЖЕ :     print , prout , printm , proutm .


                 Ф у н к ц и я    chartof
                 ------------------------

ВЫЗОВ :        k/chartof/ [C] .

                   где [C] - цепочка символов.

ОПИСАНИЕ :         Функция  chartof превращает цепочку литер
               в символ-метку, имеющий тело,  совпадающее  с
               заданной цепочкой литер. Функция chartof соз-
               дает и поддерживает  таблицу  символов-меток,
               порожденных ею из цепочек литер. Если цепочка
               литер встретилась в первый раз, то  создается
               пустая функция, имя которой является соответ-
               ствующим символом-меткой. Если такая  же  це-
               почка  литер  встречается  еще  раз, то новая
               функция не создается, а в качестве результата
               вырабатывается имя ранее созданной функции.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     Символ-метка.

ПРИМЕР :       k/chartof/ 'assa3434' .   -->  /assa3434/

               k/chartof/ 'ABCD' .    -->  /ABCD/

СМ.ТАКЖЕ :     ftochar , functab .


                 Ф у н к ц и я   clsget
                 ----------------------

ВЫЗОВ :        k/clsget/ .

ОПИСАНИЕ :         Функция clsget предназначена для закрытия
               файла чтения после того, как работа с ним за-
               кончена.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/clsget/ .   -->

                   В результате  выполнения  ранее  открытый
               файл чтения окажется закрытым.

СМ.ТАКЖЕ :     opnget , libget , opnput , libput , clsput .


                 Ф у н к ц и я   clsput
                 ----------------------

ВЫЗОВ :        k/clsput/ .

ОПИСАНИЕ :         Функция clsput предназначена для закрытия
               файла записи после того, как работа с ним за-
               кончена.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/clsput/ .   -->

                   В результате  выполнения  ранее  открытый
               файл записи окажется закрытым.

СМ.ТАКЖЕ :     opnput , libput , opnget , libget , clsget .


                    Ф у н к ц и я   cp
                    ------------------

ВЫЗОВ :                      k/cp/ [X].

                    где [Х] - произвольное выражение, не со-
               держащее символа '=' на нулевом  уровне  ско-
               бочной структуры.

ОПИСАНИЕ :          Функция  cp,  так  же, как и функция dg,
               находит в копилке выражение по имени и выдает
               его  в качестве результата замены, но копилка
               при этом не изменяется, т.к.  в  поле  зрения
               формируется копия выражения. Таким образом cp
               работает так:

                 поле зрения:  k/cp/ [X].  --> [Y]
                 копилка:      [E1] ([X] '=' [Y]) [E2]  -->
                                     [E1] ([X] '=' [Y]) [E2]

                    Если под именем [X] ничего не  закопано,
               cp  выдает  "пусто". Функцию cp можно было бы
               следующим образом описать через br и dg:

                   cp       ex = k/cp1/ (ex) k/dg/ ex..
                   cp1      (ex) ey = ey k/br/ ex '=' ey.

                    Это описание несколько отличается от ал-
               горитма, реализованного в  машинной  операции
               cp, тем, что терм "([X] '=' [Y])" переставля-
               ется в начало копилки, в то время как  машин-
               ная операция оставляет его на месте.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ  :    если терм "([X] '=' [Y])" - самый левый в ко-
               пилке терм с [X] слева от знака равенства, то
               [Y], если терм такого вида отсутствует в  ко-
               пилке, то [пусто].

ПРИМЕР :            Если копилка имеет вид:

                      ('aaa=bbb')('bbb=ccc')('bbb=ddd')

                    то

                      k/cp/ 'bbb'. -->  'ccc'

                    а копилка останется прежней.

СМ.ТАКЖЕ :     br , dg , dgall ,rp .


                    Ф у н к ц и я   dg
                    ------------------

ВЫЗОВ :                    k/dg/ [X].

                    где [X] - выражение, не содержащее знака
               равенства  на нулевом уровне скобочной струк-
               туры.

ОПИСАНИЕ :          Функция dg просматривает  копилку  слева
               направо  в поисках терма вида "([X] '=' [Z])"
               и, если находит, удаляет его из копилки и вы-
               дает [Z] в качестве результата замены. Если в
               копилке несколько выражений закопаны под  од-
               ним  именем,  то  выкапывается самое левое из
               них, т.е. то, которое закапывалось последним.
               При  повторном  обращении к dg с тем же аргу-
               ментом [X] будет выкопано выражение, закопан-
               ное предпоследним и т.д.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         Если копилка имеет вид:

                [E1] ([X]'='[Z]) [E2] --> [E1][E2]

                    где  [Z]   -   произвольное   выражение,
               [E1],[E2]  - произвольные цепочки структурных
               скобок, содержащих некоторые выражения, а [X]
               - выражение, не содержащее знака равенства на
               нулевом уровне скобочной структуры, то машин-
               ная операция dg возвращает значение [Z], ина-
               че [пусто].

ПРИМЕР :            Если копилка имеет вид:

                      ('aaa=bbb')('bbb=ccc')('bbb=ddd')

                    то

                      k/dg/ 'bbb'. -->  'ccc'

                    а копилка примет вид:

                      ('aaa=bbb')('bbb=ddd')

СМ.ТАКЖЕ :     br , dgall , cp , rp .


                  Ф у н к ц и я   dgall
                  ---------------------

ВЫЗОВ:                k/dgall/.

ОПИСАНИЕ:           Функция dgall позволяет вынуть из копил-
               ки все содержимое и поместить его в поле зре-
               ния.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ:           Пусть  копилка  содержит  выражение [E].
               Тогда результатом обращения к dgall будет [E]
               ,  причем  в копилке останется пустое выраже-
               ние.

ПРИМЕР :            Если копилка имеет вид:

                      ('aaa=bbb')('bbb=ddd')

                    то

                 k/dgall/.  -->   ('aaa=bbb')('bbb=ddd')

                    а копилка станет пустой.

СМ. ТАКЖЕ:     br , dg , cp , rp .


                   Ф у н к ц и я   div
                   -------------------

ВЫЗОВ :        k/div/ ( [N1] ) [N2] .

                   где [N1] и [N2] - целые числа.

ОПИСАНИЕ :         Функция div предназначена для целочислен-
               ного деления числа [N1] на число [N2].
                   Попытка  делить на ноль приводит к авосту
               "отождествление невозможно".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         Целое число [N]  ,  представляющее  собой
               частное от деления [N1] на [N2].

ПРИМЕР :       k/div/ (/5/) /3/  .      -->  /1/

               k/div/(/5/) '-'/3/ .     -->  '-'/1/

               k/div/('-'/5/) /3/ .     -->  '-'/1/

               k/div/('-'/5/) '-'/3/ .  -->  /1/

СМ.ТАКЖЕ :     add , mul , sub , dr , p1 , m1 .


                    Ф у н к ц и я    dr
                    -------------------

ВЫЗОВ :        k/dr/ ( [N1] ) [N2] .

                   где [N1] и [N2] - целые числа.


ОПИСАНИЕ :        Функция dr предназначена для целочислен-
               ного деления с остатком числа [N1] на число
               [N2].
                   Попытка  делить на ноль приводит к авосту
               "отождествление невозможно".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [Q] ( [R] )

                   где [Q] - целое число - частное от  деле-
               ния  [N1] на [N2] , а [R] - целое число - ос-
               таток.
                   И частное, и остаток выдаются без  незна-
               чащих  нулей  и  без знака '+'. Нулевые [Q] и
               [R] выдаются в виде макроцифры /0/.
                   Знаки чисел учитываются  следующим  обра-
               зом:  сначала  производим деление, не обращая
               внимания на знаки, а затем частному и остатку
               приписываем  такие  знаки,  чтобы выполнялось
               соотношение:

                  [N1] = [Q] * [N2] + [R]

                   т.е. частное положительно, если знаки де-
               лимого и делителя совпадают, и отрицательно в
               противном случае, а не  равный  нулю  остаток
               всегда имеет знак делимого.

ПРИМЕР :       k/dr/ (/5/) /3/ .        -->  /1/ (/2/)

               k/dr/ (/5/) '-'/3/ .    -->  '-'/1/ (/2/)

               k/dr/ ('-'/5/) /3/ .     -->  '-'/1/ ('-'/2/)

               k/dr/ ('-'/5/) '-'/3/ .  -->  /1/ ('-'/2/)

СМ.ТАКЖЕ :     add , mul , sub , div , p1 , m1 .


                  Ф у н к ц и я   first
                  ---------------------

ВЫЗОВ :        k/first/ [N] [E] .

                   где  [N] - макроцифра, а [E] - произволь-
               ное об'ектное выражение.

ОПИСАНИЕ :         Эта  функция предназначена для отщепления
               от начала выражения части, имеющей  указанную
               длину. Обращение к ней имеет вид.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         Если [E]  представляет  собой  последова-
               тельность из менее, чем [N] термов, результа-
               том замены является выражение

                          '*' [E]

                   Если же длина [E] не меньше, чем [N] тер-
               мов, результатом замены является

                       ( [E1] ) [E2]

                   где  [E1]  и  [E2] - такие выражения, что
               [E]=[E1][E2] и при этом [E1] является  после-
               довательностью из ровно [N] термов.

ПРИМЕР :       k/first/ /2/ 'A'('B')'C'. -->  ('A'('B')) 'C'

               k/first/ /5/ 'A'('B')'C'. -->  '*A'('B')'C'

СМ.ТАКЖЕ :     type , last , lengr , lengw , multe .


                  Ф у н к ц и я   ftochar
                  -----------------------

ВЫЗОВ :        k/ftochar/ [F]  .

                  где [F] - символ-метка.

ОПИСАНИЕ :         Эта функция превращает символ-метку в це-
               почку об'ектных  символов,  которая  является
               телом символа-метки.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         Результатом   замены   является   цепочка
               об'ектных символов, являющаяся телом  символа
               [F].

ПРИМЕР :       k/ftochar/ /assa3434/  .  -->  'assa3434'

               k/ftochar/ /ABCD/  .   -->  'ABCD'

СМ.ТАКЖЕ :     chartof , functab .


                  Ф у н к ц и я   functab
                  -----------------------

ВЫЗОВ :        k/functab/ [F] .

                    где [F] - символ-метка.

ОПИСАНИЕ :         В некоторых случаях требуется, чтобы сим-
               вол-метка, создаваемый из цепочки  литер  [C]
               заведомо  совпадал с символом-меткой, опреде-
               ленным в рефал-программе и имеющим тело  [C].
               Это  достигается  с  помощью функции functab.
               Эта функция регистрирует в таблице  символов,
               создаваемой  функцией chartof, указанный сим-
               вол-метку [F]. После этого, всякий раз, когда
               функция chartof будет получать цепочку литер,
               совпадающую с телом символа [F],  результатом
               функции chartof будет символ [F].

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР  :          Пусть в рефал-программе определена  неко-
               торая функция func1 . Тогда

                      k/functab/ /func1/ .  -->

               и в таблице символов функции chartof окажется
               зарегистрированным символ-метка /func1/.

СМ.ТАКЖЕ :     chartof , ftochar .


                   Ф у н к ц и я   gtr
                   -------------------

ВЫЗОВ:         k/gtr/ [X].

                    где [X] - имя статического  или  динами-
               ческого ящика.

ОПИСАНИЕ:           Извлекает  содержимое  ящика. При этом в
               ящике остается пустое выражение.
                    Эту функции можно было бы описать на РЕ-
               ФАЛе следующим образом:

                             GTR  SX  = k SX.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [Y] - содержимое ящика с именем [X].

ПРИМЕР :       Пусть статический ящик box содержит выражение
               'abc'. Тогда

                         k/gtr/ /box/. --> 'abc'

               а ящик станет пустым.

СМ. ТАКЖЕ :    new , rdr , wtr , ptr , swr .


                    Ф у н к ц и я   last
                    --------------------

ВЫЗОВ :        k/last/ [N] [E] .

                   где [N] - макроцифра, [E] - произволь-
               ное выражение.

ОПИСАНИЕ :         Эта  функция предназначена для отщепления
               от конца выражения [E] части, имеющей указан-
               ную длину [N].

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         Если  [E]  представляет  собой последова-
               тельность из менее, чем [N] термов, результа-
               том замены является

                          [E] '*'

                   Если  же  длина  [E] составляет не менее,
               чем [N] термов, результатом замены является

                       [E1] ( [E2] )

                   где [E1] и [E2] -  такие  выражения,  что
               [E]=[E1][E2]  и при этом [E2] является после-
               довательностью из ровно [N] термов.

ПРИМЕР :       k/last/ /2/ 'A'('B')'C' .  -->  'A'(('B')'C')

               k/last/ /5/ 'A'('B')'C' .  -->  'A'('B')'C*'

СМ.ТАКЖЕ :  type , first , lengr , lengw , multe .


                   Ф у н к ц и я   lengr
                   ---------------------

ВЫЗОВ :        k/lengr/ [E] .

                   где [E] - произвольное об'ектное  выраже-
               ние.

ОПИСАНИЕ :        Эта функция предназначена для вычисления
               длины аргумента, т.е. количества символов и
               скобок, составляющих [E].

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N] [E]

                   где [N] - макроцифра, которая равна длине
               выражения [E] .

ПРИМЕР :       k/lengr/ 'A' () ('A') . -->  /6/ 'A' () ('A')

СМ.ТАКЖЕ :     type , first , last , lengw , multe .


                  Ф у н к ц и и   lengw
                  ---------------------

ВЫЗОВ :        k/lengw/ [E] .

                   где  [E] - произвольное об'ектное выраже-
               ние.

ОПИСАНИЕ :         Функция lengw выдает длину выражения, из-
               меренную в термах, т.е. количество термов ну-
               левого уровня, составляющих [E].

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N] [E]

                   где [N] - макроцифра, которая равна длине
               выражения [E] .

ПРИМЕР :       k/lengw/ 'A' () ('A') . -->  /3/ 'A' () ('A')

               k/lengw/ .               -->  /0/

СМ.ТАКЖЕ :     type , first , last , lengr , multe .


                  Ф у н к ц и я   libget
                  ----------------------

ВЫЗОВ :        k/libget/ .

ОПИСАНИЕ :         Функция libget читает очередную запись из
               предварительно  открытого  с  помощью функции
               opnget файла чтения.
                   Попытка чтения из неоткрытого файла  при-
               водит  к авосту "отождествление невозможно" и
               выдаче сообщения "Unknown input file".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     /0/ - если файл прочитан до конца,
               [E] - где [E]  -  очередная  запись  из файла
                     чтения в виде строки об'ектных символов,
                     если в файле еще остались непрочитанные
                     записи.

ПРИМЕР  :      k/libget/.
                             -->

                         'это очередная прочитанная запись'

СМ.ТАКЖЕ :     opnget , clsget , opnput , libput , clsput .


                   Ф у н к ц и я  libput
                   ---------------------

ВЫЗОВ :        k/LIBPUT/ [E] .

                   где [E] - об'ектное выражение, которое не
               содержит составных символов.

ОПИСАНИЕ :         Функция libput записывает в файл, предва-
               рительно открытый с помощью  функции  opnput,
               одну  запись  [E].  При  этом все структурные
               скобки в выражении [E] преобразуются в симво-
               лы-литеры '(' и ')'. Ели аргумент [E] пуст, в
               файл добавляется пустая запись.
                   Попытка записи в неоткрытый файл приводит
               к авосту "отождествление невозможно" и выдаче
               сообщения "Unknown output file".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :          k /libput/ 'очередная запись'.  -->

               и в конце файла записи появится запись
               'очередная запись'.

СМ.ТАКЖЕ :     opnget , libget , clsget , opnput , clsput .


                    Ф у н к ц и я   mul
                    -------------------

ВЫЗОВ :        k/mul/ ( [N1] ) [N2] .

                   где [N1] и [N2] - целые числа (может быть
               пустые).

ОПИСАНИЕ :         Функция mul умножает целые числа [N1] и
               [N2].

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N] - целое число (произведение).

ПРИМЕР :       k/mul/ (/2/) '-'/2/ .  -->  '-'/4/

               k/mul/ (/2/) .         -->     /0/

СМ.ТАКЖЕ :     add , sub , dr , div , m1 , p1 .


                  Ф у н к ц и я   multe
                  ---------------------

ВЫЗОВ :        k/multe/ [N] [E] .

                   где [N] - макроцифра, а [E] - произволь-
               ное об'ектное выражение.

ОПИСАНИЕ :         Эта функция копирует (размножает) выраже-
               ние в заданном количестве экземпляров.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [E] [E]...[E]

                   где  выражение [E] повторяется [N] раз. В
               частности, если [N] равно  нулю,  результатом
               замены является пустое выражение.

ПРИМЕР :       k/multe/ /5/ 'A' .      -->  'AAAAA'

               k/multe/ /2/ 'A'('B'). -->  'A'('B')'A'('B')

               k/multe/ /0/ .          -->  [пусто]

СМ.ТАКЖЕ :     type , first , last , lengr , lengw .


                   Ф у н к ц и я   m1
                   ------------------

ВЫЗОВ :        k/m1/ [N] .

                                  где [N] - макроцифра.

ОПИСАНИЕ :         Функция m1 производит вычитание единицы
                              из макроцифры.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N-1] - макроцифра, на единицу меньшая [N].

ПРИМЕР :       k/m1//10/ .  -->  /9/

                              k/m1//738/ . -->  /737/

                              k/m1/ /1/ .  -->  /0/

СМ.ТАКЖЕ :     add , sub , mul , dr , div , p1 .


                    Ф у н к ц и я   new
                    -------------------

ВЫЗОВ :        k/new/ [E].

               где [E] - произвольное выражение, возможно
               пустое.

ОПИСАНИЕ :          В результате выполнения машинной  опера-
               ции new создается новый ящик и в него помеща-
               ется выражение [E]. Одновременно  порождается
               символ-ссылка  [R],  который  является именем
               новой обменной функции, обеспечивающей доступ
               к созданному ящику.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :          символ-ссылка  [R]  - имя новой обменной
               функции (динамического ящика).

ПРИМЕР :       Допустим

                  k/new/ 'информация'. --> /%1432A566/

                    Тогда  вновь  порожденный   динамический
               ящик  с именем (адресом) /%1432A566/ содержит
               выражение 'информация'.

СМ.ТАКЖЕ :     gtr , rdr , wtr , ptr , swr .


                  Ф у н к ц и я   numb
                  --------------------

ВЫЗОВ :        k/numb/ [D] .

                   где  [D] - цепочка символов-литер, являю-
               щаяся десятичной записью целого числа со зна-
               ком или без него, или пустое выражение.

ОПИСАНИЕ :         Преобразует целое  число  из  символьного
               представления в макроцифру.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N] - число [D] в виде макроцифры.

ПРИМЕР :       k/numb/'1000' .   -->      /1000/

               k/numb/ .        -->      /0/

               k/numb/'+025' .  -->      /25/

СМ.ТАКЖЕ :     symb .


                  Ф у н к ц и я   opnget
                  ----------------------

ВЫЗОВ :        k/opnget/ [filespec]  .

                   где  [filespec]  - это цепочка символов ,
               которая представляет собой спецификацию  фай-
               ла.

ОПИСАНИЕ :         Эта функция открывает файл на чтение.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/opnget/ 'input.txt'.  -->

               k/opnget/ 'c:\refal\readfl.txt'.  -->

СМ.ТАКЖЕ :     libget , clsget , opnput , libput , clsput .


                   Ф у н к ц и я  opnput
                   ---------------------

ВЫЗОВ :        k/opnput/ [filecpec] .

                   где [filespec] - это цепочка символов,
               которая представляет собой спецификацию фай-
               ла.

ОПИСАНИЕ :         Эта функция открывает файл на запись .

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/opnput/ 'output.txt'.  -->

               k/opnput/ 'c:\refal\writefl.txt'.  -->


СМ.ТАКЖЕ :     opnget , libget , clsget , libput , clsput .


                    Ф у н к ц и я   print
                    ---------------------

ВЫЗОВ :        k/print/ [E] .

                   где [E] - произвольное об'ектное выраже-
               ние.

ОПИСАНИЕ :
                   В  результате  выполнения функции print в
               стандартный выходной поток (обычно это экран,
               но можно переназначить в файл), начиная с но-
               вой строки, выводится выражение [E].
                   Если выражение не помещается в одной  пе-
               чатной  строке, оно продолжается на следующих
               строках. Печать пустого [E] вызывает  пропуск
               одной печатной строки.
                   При использовании функции print выражение
               [E] выводится следующим образом.  Символы-ли-
               теры (об'ектные знаки) выводятся в виде соот-
               ветствующих литер. Структурные скобки  "("  и
               ")" выводятся в виде литер "(" и ")". Состав-
               ные символы печатаются в том же виде, как они
               изображаются  в рефал-программах, за исключе-
               нием того, что в качестве  ограничителей  ис-
               пользуется не "/", а апостроф "'".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [E]

ПРИМЕР :       k/print/ 'функция'(/f1/). --> 'функция'(/f1/).

               и на экране (если вывод не переназначен при
               запуске) появится надпись

                              функция('f1')

СМ.ТАКЖЕ :     prout , printm , proutm , card .


                  Ф у н к ц и я   printm
                  ----------------------

ВЫЗОВ :        K/printm/ [E] .

                 где [E] - произвольное об'ектное выражение.

ОПИСАНИЕ :         В результате  выполнения функции printm в
               стандартный выходной поток (обычно это экран,
               но можно переназначить в файл), начиная с но-
               вой строки, выводится выражение [E].
                   Если выражение не помещается в одной  пе-
               чатной  строке, оно продолжается на следующих
               строках. Печать пустого [E] вызывает  пропуск
               одной печатной строки.
                   При  использовании функции printm выраже-
               ние выводится в том же виде,  в  котором  оно
               записывается   в  исходных  рефал-программах.
               Единственное различие заключается в том,  что
               при  переходе на следующую строку не ставится
               признак продолжения "+".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [E]

ПРИМЕР :       k/printm/ 'функция'(/f1/).-->'функция'(/f1/).

               и на экране (если вывод не переназначен при
               запуске) появится строка:

                           'функция'(/f1/).

СМ.ТАКЖЕ :     print , prout , proutm , card .


                   Ф у н к ц и я  prout
                   --------------------

ВЫЗОВ :        k/prout/ [E] .

                   где [E] - произвольное об'ектное выраже-
               ние.

ОПИСАНИЕ :
                   В  результате  выполнения функции prout в
               стандартный выходной поток (обычно это экран,
               но можно переназначить в файл), начиная с но-
               вой строки, выводится выражение [E].
                   Если выражение не помещается в одной  пе-
               чатной  строке, оно продолжается на следующих
               строках. Печать пустого [E] вызывает  пропуск
               одной печатной строки.
                   При использовании функции prout выражение
               [E] выводится следующим образом.  Символы-ли-
               теры (об'ектные знаки) выводятся в виде соот-
               ветствующих литер. Структурные скобки  "("  и
               ")" выводятся в виде литер "(" и ")". Состав-
               ные символы печатаются в том же виде, как они
               изображаются  в рефал-программах, за исключе-
               нием того, что в качестве  ограничителей  ис-
               пользуется не "/", а апостроф "'".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/prout/ 'это'(/func/). --> 'это'(/func/).

               и на экране (если вывод не переназначен при
               запуске) появится надпись

                              это('func')

СМ.ТАКЖЕ :     print , printm , proutm , card .


                  Ф у н к ц и я   proutm
                  ----------------------

ВЫЗОВ :        K/proutm/ [E] .

                 где [E] - произвольное об'ектное выражение.

ОПИСАНИЕ :         В результате  выполнения функции proutm в
               стандартный выходной поток (обычно это экран,
               но можно переназначить в файл), начиная с но-
               вой строки, выводится выражение [E].
                   Если выражение не помещается в одной  пе-
               чатной  строке, оно продолжается на следующих
               строках. Печать пустого [E] вызывает  пропуск
               одной печатной строки.
                   При  использовании функции proutm выраже-
               ние выводится в том же виде,  в  котором  оно
               записывается   в  исходных  рефал-программах.
               Единственное различие заключается в том,  что
               при  переходе на следующую строку не ставится
               признак продолжения "+".

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       k/proutm/ 'функция'(/f1/).-->'функция'(/f1/).

               и на экране (если вывод не переназначен при
               запуске) появится строка:

                           'функция'(/f1/).

СМ.ТАКЖЕ :     print , prout , printm , card .


                    Ф у н к ц и я  ptr
                    ------------------

ВЫЗОВ:         k/PTR/ [R] [E].

                    где [R] - имя ящика, а [E] -  произволь-
               ное выражение.

ОПИСАНИЕ:           Машинная операция ptr добавляет в ящик с
               именем [R] новую информацию [E].
                    ptr можно было бы описать на Рефале сле-
               дующим образом:

                      PTR      SX EY = k SX k SX. EY.

               однако машинная операция  ptr,  в отличие  от
               вышеприведенной  функции,  проверяет является
               ли первый символ ее аргумента  именем ящика.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ:           Результатом замены является пустое выра-
               жение, а содержимое ящика меняется так:

                             [E0]  -->  [E0][E]

               где [E0] - старое содержимое ящика.

ПРИМЕР:        Пусть ящик с именем  /box/ содержит выражение
               'око'. Тогда

                         k/ptr/ /box/ 'рок'. --> [пусто]

               и  ящик /box/ содержит:  'окорок'.

СМ. ТАКЖЕ:     new , gtr , rdr , wtr , swr .


                   Ф у н к ц и я   p1
                   ------------------

ВЫЗОВ :        k/p1/ [N] .

                   где [N] - макроцифра.

ОПИСАНИЕ :         Функция p1 производит прибавление единицы
               к макроцифре.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [N+1] - макроцифра, на единицу большая [N].

ПРИМЕР :       k/p1//10/ .  -->  /11/

               k/p1//738/ . -->  /739/

               k/p1/ /1/ .  -->  /2/

СМ.ТАКЖЕ :     add , sub , mul , dr , div , m1 .


                   Ф у н к ц и я   rdr
                   -------------------

ВЫЗОВ:         k/rdr/ [X].

                    где [X] - имя статического  или  динами-
               ческого ящика.

ОПИСАНИЕ:           Выдает  содержимое  ящика в поле зрения,
               но ящик при этом не изменяется, то есть  про-
               исходит копирование его содержимого. Эту фун-
               кцию можно было бы описать на РЕФАЛе  следую-
               щим образом:

                    RDR SX = k/RDR1/ SX k SX..
                    RDR1 SX EY = EY k SX EY.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [Y] - содержимое ящика с именем [X].

ПРИМЕР :       Пусть статический ящик box содержит выражение
               'abc'. Тогда

                         k/rdr/ /box/. --> 'abc'

               а ящик по-прежнему содержит 'abc' .

СМ. ТАКЖЕ :    new , gtr , wtr , ptr , swr .


                    Ф у н к ц и я   rp
                    ------------------

ВЫЗОВ:         k/rp/ [X] '=' [Y].

               где [X] и [Y] - произвольные выражения.

ОПИСАНИЕ:           Функция   rp   добавляет в копилку новое
               выражение и выбрасывает выражение, закопанное
               в  последний раз под тем же именем. Таким об-
               разом, копилка преобразуется так:

                 [E1] ([X] '=' [Z]) [E2]     -->

                           [E1] ([X] '=' [Y]) [E2]

                    Если под именем [X] ничего не было зако-
               пано, то функция rp делает то же самое, что и
               br.
                    Эквивалентное описание на  РЕФАЛе  имеет
               вид:

                 RP       EX '=' EY = k/RP1/ k/DG/ EX.. +
                                      k/BR/ EX '=' EY.
                 RP1      E1 =

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ:      [пусто]

ПРИМЕР   :          Если в копилке, содержащей некоторое вы-
               ражение  [E], под именем  'X'  ничего не было
               закопано, то в результате выполнения

                 k/rp/ 'X=A'. k/rp/ 'X=B'.

                    копилка преобразуется следующим образом:

               сначала       [E]  -->  ('X=A') [E]

               а затем       ('X=A') [E]  -->  ('X=B') [E]

СМ.ТАКЖЕ :     br , dg , dgall , cp .


                   Ф у н к ц и я     sub
                   ---------------------

ВЫЗОВ :           k/sub/ ([N1]) [N2] .

               где [N1] и [N2] - целые числа (может быть -
               пустые).

ОПИСАНИЕ :     Функция sub предназначена для вычитания  [N2]
               из [N1] .

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ     : Результатом вызова функции sub является целое
               число. Если результат положителен - знак '+'
               не ставитcя.

ПРИМЕРЫ :      k/sub/ (/1/) /2/ .     -->    '-' /1/

               k/sub/ (/2/)  .        -->     /2/

СМ.ТАКЖЕ :     add , mul , dr , div , p1 , m1 .


                    Ф у н к ц и я  swr
                    ------------------

ВЫЗОВ :        k/swr/ [R] [E].

                    где  [R] - имя ящика, [E] - произвольное
               выражение.

ОПИСАНИЕ :          Записывает в ящик  новую  информацию,  а
               старую  выдает  в поле зрения. Таким образом,
               содержимое ящика меняется так:

                          [E0]  -->  [E]

                    где [E0] - старое содержимое ящика.
                    Эту функцию можно было бы описать на РЕ-
               ФАЛе следующим образом:

                         SWR      SX EY = k SX EY.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [E0] - старое содержимое ящика.

ПРИМЕР :       Пусть статический ящик box содержит выражение
               'abc'. Тогда

                         k/swr/ /box/ 'def'. --> 'abc'

               а ящик содержит 'def' .

СМ. ТАКЖЕ :    new , gtr , rdr , wtr , ptr .


                   Ф у н к ц и я   symb
                   --------------------

ВЫЗОВ :        k/SYMB/ [N]  .

                   где [N] - целое число в виде макроцифры.

ОПИСАНИЕ :         Преобразует целое  число  из  макроцифры
               в символьное представление.

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :         [D]  - цепочка символов-литер, являющаяся
               записью числа [N] в десятичной системе  счис-
               ления.Нулевой результат изображается как '0'.


ПРИМЕР :       k/symb/ /1000/ .         -->  '1000'

               k/symb/ .                -->  '0'

               k/symb/ /0/ .            -->  '0'

СМ.ТАКЖЕ :     numb .


                   Ф у н к ц и я   type
                   --------------------

ВЫЗОВ :        k/type/ [E] .

                 где [E] - произвольное об'ектное выражение.

ОПИСАНИЕ :         Функция type предназначена для  распозна-
               вания типа терма, с которого начинается выра-
               жение. Эта функция не дает никаких новых воз-
               можностей  по  сравнению с теми, которые дает
               использование спецификаторов. Она включена  в
               библиотеку  только для того, чтобы обеспечить
               совместимость с другими реализациями  рефала,
               и имеет следующее описание на Рефале/2:

                       start
                        entry  type
               type     S(F)X E1 = 'F' SX E1
                        S(N)X E1 = 'N' SX E1
                        S(R)X E1 = 'R' SX E1
                        S(L)X E1 = 'L' SX E1
                        S(D)X E1 = 'D' SX E1
                        S(O)X E1 = 'O' SX E1
                        (EX) E1  = 'B' (EX) E1
                                 = '*'
                        end

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [Z] [E]

                   где  [Z]  - это об'ектный символ, который
               равен :

                   - 'F' если [E] начинается с символа-мет-
                         ки;

                   - 'N' если [E] начинается с символа-числа
                         (макроцифры);

                   - 'R' если [E] начинается с символа-ссыл-
                         ки;

                   - 'L' если [E] начинается с буквы (рус-
                         ской или латинской);

                   - 'D' если [E] начинается с цифры.

                   - 'O' если [E] начинается с символа-ли-
                         теры (об'ектного знака);

                   - 'B' если [E] начинается с терма вида
                         ([e]),   где   [e]   - произвольное
                         об'ектное выражение;

                   - '*' в остальных случаях.


ПРИМЕР :       k/type/ /f1/ 'aaa' . -->  'F' /f1/ 'aaa'

               k/type/ /%11111111/ 'a'. -->

                                     'R'/%11111111/ 'a'.

               k/type/  'aaa' . -->  'L'  'aaa'

               k/type/  '9aaa' . -->  'D'  '9aaa'

               k/type/  '-aaa' . -->  'O'  '-aaa'

               k/type/ ('aaa') . -->  'B'  ('aaa')

               k/type/  .   -->  '*'

СМ.ТАКЖЕ :     first , last , lengr , lengw , multe .


                    Ф у н к ц и я  wtr
                    ------------------

ВЫЗОВ :        k/wtr/ [R] [E].

                    где  [R] - имя ящика, [E] - произвольное
               выражение.

ОПИСАНИЕ :          Помещает в ящик  новую  информацию,  при
               этом старое содержимое ящика уничтожается. То
               есть, содержимое ящика меняется так

                               [E0]  -->  [E]

                    где [E0] - старое содержимое ящика.
                    Эту функцию можно было бы описать на РЕ-
               ФАЛе следующим образом:

                      WTR      SX EY = k/WTR1/ k SX EY..
                      WTR1     EY =

ВОЗВРАЩАЕМОЕ
ЗНАЧЕНИЕ :     [пусто]

ПРИМЕР :       Пусть статический ящик box содержит выражение
               'abc'. Тогда

                         k/wtr/ /box/ 'def'. -->  [пусто]

               и ящик содержит 'def' .

СМ. ТАКЖЕ :    new , gtr , rdr , swr , ptr .
