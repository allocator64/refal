
     Система программирования РЕФАЛ/2 для ПЭВМ IBM PC.
                 Описание входного языка.


                    С о д е р ж а н и е

    Введение
 1. Назначение языка
 2. Обрабатываемые данные
 3. Функции
 4. Переменные
 5. Рекурсивные функции
 6. Снятие неоднозначности при отождествлении
 7. Спецификаторы переменных
 8. Общая структура программы
 9. Пустые функции
10. Модули
11. Первичные функции
12. Копилка
13. Статические и динамические ящики


                         Введение

    Различные описания языка РЕФАЛ отличаются в некоторых
деталях. Вариант РЕФАЛа, соответствующий [Бр 1977, т 1974],
получил название "базисного РЕФАЛа".
    В системе программирования РЕФАЛ-2 для ЕС ЭВМ в качестве
входного языка служит некоторое расширение базисного РЕФАЛа.
Это же расширение было реализовано в трансляторе РЕФАЛа для
БЭСМ-6 в рамках мониторной системы "Дубна" [Кпртр 1975, Кр
1975]. Система программирования РЕФАЛ-2 для ПЭВМ совместима
по входному языку с реализациями для ЕС ЭВМ и БЭСМ-6.
    Ниже описан входной язык системы программирования РЕ-
ФАЛ-2, который в дальнейшем для краткости именуется просто
"РЕФАЛ".

                    1. Назначение языка

    Язык РЕФАЛ (алгоритмический язык рекурсивных функций)
был создан в качестве абстрактного метаалгоритмического язы-
ка, предназначенного для формализации семантики алгоритми-
ческих языков [Т 1966, Т 1968, Бр 1977].
    Хотя РЕФАЛ был задуман как метаалгоритмический язык, он
представляет собой некоторый язык для обработки символьной
информации, поэтому, помимо описания семантики алгоритмичес-
ких языков, он нашел и другие, не менее важные применения. В
первую очередь это машинное выполнение громоздких аналити-
ческих выкладок в теоретической физике и прикладной матема-
тике, интерпретация и компиляция языков программирования,
машинное доказательство теорем, моделирование целенаправлен-
ного поведения и т.п. Общим для всех этих применений являет-
ся то, что мы заставляем машину совершать сложные преобразо-
вания над об'ектами, определенными в некоторых формализован-
ных языках (алгоритмические языки, язык алгебры, язык исчис-
ления предикатов и т.д.).


                 2. Обрабатываемые данные

    Данные, обрабатываемые РЕФАЛ-программами, являются язы-
ковыми об'ектами, т.е. некоторыми последовательностями зна-
ков.
    Следующие знаки имеют в РЕФАЛ-программах особое, фикси-
рованное значение:
          k . ( ) / ' =  S W V E T s w v e t
    Эти знаки называются с п е ц и а л ь н ы м и   з н а -
к а м и.
    Из знаков строятся более крупные единицы - с и м в о -
л ы, т е р м ы и в ы р а ж е н и я.
    С и м в о л является минимальной семантической единицей,
не расчленимой на составные части средствами языка РЕФАЛ.
    Символы делятся на два класса: с о с т а в н ы е
с и м в о л ы   и   с и м в о л ы-л и т е р ы (или, как их
еще называют, "об'ектные знаки").
    Любой составной символ имеет следующий вид:
          /[тело составного символа]/
    где [тело составного символа] - это последовательность
литер, не содержащая литеру "/".
    Множество составных символов разбивается на непересекаю-
щиеся классы, в соответствии с тем, какой вид имеют их тела.
В данной реализации РЕФАЛа имеются следующие классы состав-
ных символов: символы-метки, символы-числа и символы-ссылки.
    С и м в о л а м и - м е т к а м и называются составные
символы, телом которых является идентификатор, т.е. последо-
вательность букв, цифр и знаков "-", начинающаяся с буквы.
Длина тела символа-метки не ограничивается, однако принима-
ются во внимание только первые 255 литер тела, а все после-
дующие - игнорируются. Таким образом, все символы-метки, у
тел которых совпадают первые 255 литер, считаются совпадаю-
щими.
   Например, следующие символы являются символами-метками:

           /аLрна/
           /L2а4/
           /этопримердлиннойметки/
           /это-пример-другой-длинной-метки/
           /Z---Z---/


   С и м в о л а м и - ч и с л а м и называются составные
символы, тело которых представляет собой целое неотрицатель-
ное число, т.е. последовательность десятичных цифр. Напри-
мер:
          /0/  /1/  /512/  /23/
   Тело символа-числа должно находиться в  диапазоне от 0 до
64535 (2**16-1).
    С и м в о л а м и - с с ы л к а м и называются составные
символы, тело которых начинается с литеры "%", вслед за ко-
торой идет восемь шестнадцатеричных цифр. Например:

          /%00fffac9/  /%ffffffff/ /%abcdefab/

    Символы-ссылки нельзя употреблять в качестве констант в
РЕФАЛ-программах, однако они могут порождаться в процессе
работы РЕФАЛ-программы и входить в обрабатываемые выражения.
Назначение и использование символов-ссылок будет описано ни-
же.
    Символы-метки используются в программах в качестве имен
функций. Символы-числа служат для обозначения чисел.
    Помимо составных символов имеется еще один класс симво-
лов - символы-литеры. Любой символ-литера имеет следующий
вид:
          '[литера]'
где [литера] - произвольная литера, отличная от апострофа.
    Символы-литеры служат для обозначения литер. Так как
апостроф тоже является литерой, которую нужно уметь обраба-
тывать, для него имеется особое обозначение:
          ''
т.е. два апострофа, идущих подряд.
    Следует заметить, что символ
          ' '
    обозначает не апостроф, а литеру "пробел", которая явля-
ется такой же полноценной литерой, как и все остальные.
    Более крупной, чем символ, единицей является в ы р а - ж
е н и е.
    Выражение строится из с и м в о л о в, круглых скобок
"(" и ")" (именуемых с т р у к т у р н ы м и скобками), сим-
волов "k" и "." (именуемых ф у н к ц и о н а л ь н ы м и или
конкретизационными скобками) и  п е р е м е н н ы х.

    Структурные скобки придают обрабатываемым об'ектам
структуру дерева. Назначение функциональных скобок и пере-
менных об'ясняется в следующих разделах.
    В ы р а ж е н и е м называется произвольная последова-
тельность символов, переменных и скобок, правильно построен-
ная относительно скобок. Например:
          'A' 'B' 'C' ()
           (('A') 'B'()) ()
           kk/X/. (k/Y/.).
    Т е р м о м называется выражение, которое представляет
собой либо символ, либо выражение, заключенное в структурные
или функциональные скобки. Например:
           '+'
           ( 'A' 'B' 'C' () )
           ((()) ())
           k/P1/ /1/.
    Таким образом, всякое выражение есть последовательность
из некоторого (быть может - нулевого) числа термов.
    Приведенные выше определения выражения и терма можно
формализовать следующим образом:

      [выражение] ::=   [пусто] ! [терм] [выражение]
      [терм] ::=   [символ] ! [переменная] !
                   [структурный терм] !
                   [функциональный терм]
      [структурный терм] ::=      ( [выражение] )
      [функциональный терм] ::=   k [выражение] .
      [пусто] ::=

    Очень часто приходится иметь дело не с отдельными симво-
лами-литерами, а с цепочками из нескольких подряд идущих ли-
тер. Для таких случаев предусмотрено сокращенное обозначе-
ние. а именно, литеры записываются подряд и вся цепочка ли-
тер заключается в апострофы. Например, цепочку литер "ABC",
изображаемую как

          'A' 'B' 'C'

можно в сокращенной форме записывать как


          'ABC'

    Если цепочка литер содержит апострофы, они изображаются
парами апострофов. При этом цепочка, составленная из одних
апострофов, удваивается, но апострофами дополнительно не об-
рамляется. Например:


          ABC     -->    'ABC'
           A'C    -->    'A''C'
           '      -->    ''
           ''     -->    ''''
           'A'B   -->    '''A''B'
           A'B'   -->    'A''B'''

где стрелка "-->" обозначает слова "изображается в виде".
    Таким образом, одну и ту же цепочку символов-литер можно
изобразить многими способами. Например, цепочка литер "A'B"
может быть представлена любым из следующих способов:

          'A' '' 'B'
           'A''' 'B'
           'A' '''B'
           'A''B'

    Для повышения наглядности РЕФАЛ-программы можно встав-
лять любое количество пробелов между переменными, скобками,
составными символами и цепочками литер. Цепочку литер можно
разбить на несколько цепочек, но при этом между получившими-
ся частями обязательно должен стоять по крайней мере один
пробел, так как

          'A' 'B'   обозначает  AB
           'A''B'    обозначает  A'B

    Кроме того, следует обратить внимание на то, что струк-
турные скобки "(" и ")" в рефале н е я в л я ю т с я симво-
лами. Поэтому структурные скобки не имеют ничего общего с
символами-литерами '(' и ')'.


                        3. Функции

    Всякая программа, написанная на рефале, определяет неко-
торый набор функций. Каждая из этих функций имеет один аргу-
мент, значениями которого могут быть выражения.
    Аргументами функций могут быть не произвольные выраже-
ния, а только такие, которые не содержат функциональных ско-
бок и переменных. Такие выражения в дальнейшем именуются
о б ' е к т н ы м и.
    В общепринятой математической записи обращение к функции
FUNC с аргументом [ARG] имеет следующий вид:

          FUNC([ARG])

    В РЕФАЛе же принят другой синтаксис для вызовов функций:

                 k/FUNC/ [ARG].

    т.е вызов функции заключается в функциональные скобки
"k" и ".", а имя функции указывается с помощью символа-мет-
ки. Фактически, имя вызываемой функции представляет собой
часть функционального терма - первый символ его содержимого.
    Возникает вопрос, почему же в РЕФАЛе функции имеют толь-
ко один аргумент? Ответ заключается в том, что список из
нескольких аргументов является некоторым выражением, поэтому
всякое обращение к функции от нескольких аргументов

          FUNC([ARG1], [ARG2], ..., [ARGN])

    можно рассматривать как обращение к функции от одного
"большого" аргумента:

          k FUNC ([ARG1]) ([ARG2]) ... ([ARGN]) .

    П р о г р а м м а на языке РЕФАЛ представляет собой опи-
сание некоторого набора функций. Описание каждой функции
имеет вид:

FUNC
          [L-1] = [R-1]

          [L-2] = [R-2]
          . . . . . ..
          [L-N] = [R-N]

где "FUNC" - имя функции, а

         [L-I] = [R-I]

суть   п р е д л о ж е н и я   или  п р а в и л а    к о н -
к р е т и з а ц и и.
    Каждое предложение является указанием для замены одного
выражения на другое, поэтому оно состоит из левой части
[L-I] (заменяемое выражение) и правой части [R-I] (результат
замены). Синтаксически [L-I] и [R-I] являются выражениями.

    Перед левой частью каждого предложения должен находиться
хотя бы один пробел.
    Если предложение не помещается в очередной строке, его
можно перенести на следующие строки. Перенос допускается де-
лать в тех местах, где разрешается вставлять пробелы. В лю-
бом из таких мест можно поставить знак "+" и продолжить
предложение с любой позиции следующей строки.
    Имя функции не обязано располагаться на отдельной стро-
ке. Его можно поместить в начале той строки, в которой нахо-
дится первое предложение. При этом имя функции отделяется от
начала предложения одним или несколькими пробелами. В этом
случае описание функции имеет следующий вид:
FUNC      [L-1] = [R-1]
          [L-2] = [R-2]
          . . . . . ..
          [L-N] = [R-N]
    С е м а н т и к а РЕФАЛ-программы описывается в терминах
абстрактной Р Е Ф А Л - м а ш и н ы. РЕФАЛ-машина имеет два
запоминающих устройства: п о л е   п а м я т и   и   п о л е
з р е н и я.
    Перед началом работы в поле памяти заносится описание
набора функций, а в поле зрения - выражение, подлежащее об-
работке.
    Пусть, например, в поле памяти находится единственное
предложение:
XXX      = '137'
а в поле зрения - выражение
         k/XXX/.
    Тогда РЕФАЛ-машина заменит содержимое поля зрения на вы-
ражение
         '137'
    и остановится, поскольку в поле зрения не осталось ни
одной пары функциональных скобок.
    А что будет, если занести в поле памяти два предложения:
XXX      = '137'
         = '274'
    Теперь для вычисления "k/XXX/." пригодно не одно, а два
предложения. Неоднозначность устраняется следующим образом.
РЕФАЛ-машина просматривает предложения в том порядке, в ко-
тором они стоят в описании функции и применяет первое из
них, которое окажется подходящим. Таким образом, в данном
случае "k/XXX/." будет заменено на '137'.
    Поле зрения может содержать сколь угодно много функцио-
нальных термов, которые могут быть как угодно вложены друг в
друга. Поэтому нужно договориться, каким образом РЕФАЛ-маши-
на будет выбирать выражение, с которого надо начинать про-
цесс вычисления.
    Пусть в поле зрения находится выражение, в котором име-
ются функциональные термы. Тогда некоторые из этих термов
являются самыми внутренними, т.е. не содержат внутри себя
других функциональных термов. Самый левый из таких термов мы
будем называть в е д у щ и м.
    Теперь опишем работу РЕФАЛ-машины (для частного случая,
когда РЕФАЛ-программа не содержит переменных).
    Работа РЕФАЛ-машины разбивается на шаги. В начале каждо-
го шага РЕФАЛ-машина находит ведущий функциональный терм.
    Пусть этот терм имеет вид:

          k/FUNC/ [ARG].

    где "FUNC" - имя некоторой функции, а [ARG] - об'ектное
выражение. Таким образом, предполагается, что содержимое ве-
дущего терма начинается с символа-метки. (Случай, когда это
не выполнено, будет рассмотрен позже.)
    РЕФАЛ-машина находит описание функции "FUNC" и начинает
сравнивать [ARG] с левыми частями предложений в описании
этой функции.
    Пусть I - номер самого первого предложения, для которого
[L-I]=[ARG]. Тогда РЕФАЛ-машина производит з а м е н у веду-
щего функционального терма, т.е.

          k/FUNC/ [ARG].

заменяется на правую часть предложения

          [R-I]

    после чего РЕФАЛ-машина переходит к исполнению следующе-
го шага.
    Если же РЕФАЛ-машина не находит ни одного предложения
для которого [L-I]=[ARG], она сообщает, что "отождествление
невозможно" и останавливается. Это означает, что либо прог-
рамма на РЕФАЛе, либо исходные данные для нее заданы невер-
но.
    Работа РЕФАЛ-машины продолжается до тех пор, пока в поле
зрения имеется хотя бы один функциональный терм. Если же в
поле зрения после завершения очередного шага не остается ни
одного функционального терма, РЕФАЛ-машина сообщает, что
"вычисление окончено" и останавливается. При этом, результа-
том работы РЕФАЛ-машины считается выражение, которое нахо-
дится в поле зрения.
    Пусть, например, поле памяти содержит следующий набор
функций:

XXX
          = '137'
          = '274'
YYY
          = '2'



ADD
          ('137') '2' = '139'

А в поле зрения находится выражение

         k/ADD/ (k/XXX/.) k/YYY/. .

    Тогда на первом шаге ведущим будет терм "k/XXX/.", кото-
рый заменится на '137', в результате чего поле зрения примет
вид:
         k/ADD/ ('137') k/YYY/..

    Теперь подлежит вычислению терм "k/YYY/.", что дает

         k/ADD/ ('137') '2'.

    На третьем шаге применяется функция "ADD", и в поле зре-
ния оказывается выражение

         '139'

    которое уже не содержит функциональных скобок и является
окончательным результатом работы рефал-машины.


                       4. Переменные

    Средства, описанные в предыдущих разделах, позволяют
описывать только функции, области определения которых - ко-
нечные множества, ибо для каждого конкретного значения аргу-
мента приходилось предусматривать особое предложение. Ясно,
что так мы далеко не уйдем. Нужно уметь записывать предложе-
ния, применимые более, чем к одному об'ектному выражению.
Для этого нужно ввести в предложения п е р е м е н н ы е,
которые при различных применениях предложения могут прини-
мать различные значения.
    Языковые об'екты, с которыми имеет дело РЕФАЛ-машина,
это всегда выражения, которые могут быть, в частности, тер-
мами или символами. Поэтому в РЕФАЛе-2 используются перемен-
ные четырех типов:

     S-переменные,   значением  которых  могут  быть  только
        символы;
     W-переменные,   значением  которых  могут  быть  только
        термы;
     V-переменные,   значением  которых  могут  быть  только
        непустые выражения;
     E-переменные,  значениями которых  могут быть выражения
        (в том числе и пустые).

    Любая переменная имеет следующий вид:

          [признак типа][спецификация][индекс]

    [Признак типа] - это один из специальных знаков "S",
"W", "V" или "E". Он указывает, к какому из четырех вышепе-
речисленных типов принадлежит переменная.
    [Спецификация] - это описание дополнительных условий,
налагаемых на множество допустимых значений переменной. Спе-
цификация может быть пустой. В этом случае считается, что на
возможные значения переменной не налагается никаких дополни-
тельных ограничений. Т.е. значением S-переменной может быть
любой символ, значением W-переменной - любой терм, значением
V-переменной - любое непустое выражение, значением E-пере-
менной - любое (в том числе и пустое) выражение.
    [Индекс] переменной - это цифра, либо прописная буква
русского или латинского алфавитов. Индексы переменных служат
для того, чтобы различать между собой различные переменные.
    Например, S-переменными являются "S1", "S2" и "SA",
W-переменными являются "W1" и "Wх", V-переменными являются
"V9" и "VZ", E-переменными являются "E1", "E5" и "EA".
    Разрешив употреблять переменные в левых и правых частях
предложений, мы получаем мощное изобразительное средство.
Теперь, чтобы решить, применимо ли предложение

          [L] = [R]

    к об'ектному выражению [ARG], РЕФАЛ-машина должна опре-
делить, является ли [ARG] частным случаем [L], т.е. можно ли
вместо переменных, входящих в [L] подставить такие значения,
чтобы получившееся об'ектное выражение совпало с [ARG]. При
этом, значения переменных должны быть допустимыми, т.е. со-
ответствовать их типам и спецификациям. Кроме того, все
вхождения одной и той же переменной должны заменяться на од-
но и то же значение.
   Описанное выше действие РЕФАЛ-машины, по подбору значений
переменных,      называется      с и н т а к с и ч е с к и м
о т о ж д е с т в л е н и е м.
    В том случае, если отождествление левой части [L] с
[ARG] возможно, предложение является применимым, в противном
случае - неприменимым.
    Теперь мы следующим образом уточним описание работы РЕ-
ФАЛ-машины.
    На каждом шаге РЕФАЛ-машина просматривает описание функ-
ции и находит самое первое применимое предложение. Затем она
заменяет ведущий функциональный терм на правую часть этого
предложения, предварительно подставив в нее вместо перемен-
ных те значения, которые получили эти переменные в результа-
те синтаксического отождествления. Если же окажется, что все
предложения функции неприменимы, РЕФАЛ-машина сообщает, что
"отождествление невозможно" и останавливается.
    Разумеется, в правой части предложения разрешается ис-
пользовать только такие переменные, которые входят в левую
часть. Кроме того, все вхождения одной и той же переменной в
левую и правую часть должны иметь одинаковый указатель типа
переменной.
    Рассмотрим несколько примеров. Допустим, что нужно опи-
сать функцию "FIRST-SYM", которая в качестве значения выдает
первый символ аргумента. Например, чтобы результатом вычис-
ления терма

          k/FIRST-SYM/ 'Z'('AB')'+F'.

был символ 'Z', а результатом вычисления

          k/FIRST-SYM/ /X1/ /X2/.

был символ /X1/.
    Для этого достаточно ввести в поле памяти РЕФАЛ-машины
следующее описание функции:

FIRST-SYM
          SA EX = SA

    Аналогично можно описать функцию, значением которой яв-
ляется последний символ аргумента:

LAST-SYM
          EX SA = SA


                  5. Рекурсивные функции

    Поскольку правые части предложений могут содержать функ-
циональные скобки, можно описывать функции в терминах других
функций или применять рекурсию.
    Опишем, например, функцию "RеV", определенную для всех
выражений. Значением этой функции является "зеркально пере-
вернутое" исходное выражение. Так, вычисление терма

          k/REV/ 'A'('B'('CD')'F').

должно давать

          ('F'('DC')'B')'A'

    Функция "REV" описывается тремя предложениями:

REV      E1 SX   = SX k/REV/ E1.
          E1 (EX) = (k/REV/ EX.) k/REV/ E1.
          =

    Обратите внимание на то, что структурные скобки "(" и
")" не являются символами, и, в отличие от символов-литер
'(' и ')', не могут быть значениями S-переменной. Поэтому,
если аргумент кончается на правую структурную скобку, то
первое предложение функции - не применимо. В этом случае
применяется второе предложение.
    Другой пример. Функция "SYMM" принимает значение 'Т' ес-
ли аргумент - симметричное выражение (т.е. такое, которое не
изменяется в результате применения к нему функции "REV"), и
принимает значение 'F', если аргумент не является симметрич-
ным выражением.

SYMM
          EX = k/EQUAL/ (EX) k/REV/ EX..
EQUAL
          (EX) EX = 'T'
          (EX) EY = 'F'

    Функцию "SYMM" можно описать и без обращения к функции
"REV":

SYMM     = 'T'
          SX = 'T'
          SX EA SX = k/SYMM/ EA.
          (EA) = k/SYMM/ EA.
          () EA () = k/SYMM/ EA.
          (WX E1) EA (E2 WY) =  +
             k/SYMM/ WX (E1) EA (E2) WY.
          EA = 'F'


       6. Снятие неоднозначности при отождествлении

    Будем говорить, что некоторая переменная является VE-пе-
ременной, если она является V-переменной или E-переменной.
    Если левая часть предложения содержит несколько VE-пере-
менных, то может случиться, что существует несколько вариан-
тов приписывания переменным значений, приводящих к отождест-
влению левой части предложения с аргументом функции. Пусть,
например, в поле памяти находится функция

F        E1 ';' E2 = k/G/ E1.  k/F/ E2.

а в поле зрения - выражение
         <F 'A1:=A2;B1:=B2;C1:=C2'>
    Это выражение может быть отождествлено с левой частью
таким образом, что переменные "E1" и "E2" примут следующие
значения:
          E1  <--  'A1:=A2'
          E2  <--  'B1:=B2;C1:=C3'

    Однако, возможен и другой вариант отождествления, при
котором переменные примут такие значения:

          E1  <--  'A1:=A2;B1:=B2;'
          E2  <--  'C1:=C2'

    Следовательно, необходимо договориться, как поступает
РЕФАЛ-машина при наличии такой неоднозначности.
    Для устранения неоднозначности в РЕФАЛе-2 могут исполь-
зоваться два метода: отождествление слева направо и отождес-
твление справо налево.
    При отождествлении слева направо РЕФАЛ-машина выбирает
тот вариант отождествления, при котором первая слева VE-пе-
ременная принимает самое короткое значение. Если это не уст-
раняет неоднозначности, то такой же отбор производится по
второй слева VE-переменной, затем - третьей слева и т.д. В
нашем примере будет выбран первый из двух способов отождест-
вления.
    При отождествлении справа налево РЕФАЛ-машина выбирает
тот вариант отождествления, при котором первая справа VE-пе-
ременная принимает самое короткое значение. Если это не уст-
раняет неоднозначности, то такой же отбор производится по
второй справа VE-переменной, затем третьей справа и т.д. В
нашем примере будет выбран второй из двух способов отождест-
вления.
    Если мы хотим, чтобы при применении некоторого предложе-
ния использовалось отождествление справа налево, следует со-
общить об этом РЕФАЛ-машине, поместив перед левой частью
предложения ключевое слово "R", т.е. знак "R", за которым
следует хотя бы один пробел. Если же мы хотим, чтобы при
применении некоторого предложения использовалось отождеств-
ление слева направо, следует сообщить об этом РЕФАЛ-машине,
поместив перед левой частью предложения ключевое слово "L",
т.е. знак "L", за которым следует хотя бы один пробел.
    Если направление отождествления не указано явно, РЕ-
ФАЛ-машина считает, что отождествление следует выполнять
слева направо, поэтому ключевое слово "L" указывать не обя-
зательно (и оно отсутствовало во всех приведенных примерах).
    Например, описанная выше функция "F", выдаст в результа-
те замены
          k/G/ 'A1:=A2'. k/F/ 'B1:=B2;C1:=C2'.

    Но если описать "F" следующим образом:

F       R E1 ';' E2 = k/G/ E1.  k/F/ E2.

то результатом замены будет

          k/G/ 'A1:=A2;B1:=B2'. k/F/ 'C1:=C2'.

    Отождествление слева направо и справо налево широко ис-
пользуются при программировании на РЕФАЛе. В качестве приме-
ра рассмотрим функцию "MAKE-SET", которая порождает множест-
во термов, входящих в аргумент на нулевом уровне скобочной
структуры. Эта функция просматривает выражение слева направо
терм за термом. Для очередного терма проверяется, не стоит
ли справа от него точно такой же терм. Если да, то очередной
терм вычеркивается, в противном случае - оставляется. Остав-
шееся выражение обладает тем свойством, что составляющие его
термы попарно различны. Например, результатом вычисления

          k/MAKE-SET/ 'AAACBDBEAAF'.

будет выражение

          'СDBEAF'

    "MAKE-SET" описывается следующим образом:

MAKE-SET
          E1 WX E2 WX E3 =  E1 k/MAKE-SET/ E2 WX E3.
          E1 = E1

    Функция "MAKE-SET" вычеркивает все вхождения каждого
терма, кроме последнего. Нетрудно, однако описать функцию
"MAKE-SETR", которая будет вычеркивать все вхождения терма,
кроме первого. Для этого можно воспользоваться отождествле-
нием справа налево.

MAKE-SETR
          R E3 WX E2 WX E1 =  k/MAKE-SETR/ E3 WX E2. E1
            E1 = E1

    При желании можно описать функцию "MAKE-SET" так, чтобы
при отождествлении не возникало неоднозначностей:

MAKE-SET
          WA E1 = k/MAKE-SET-/ WA () E1.
          =
 MAKE-SET-
          WA (E1) WA E2 = k/MAKE-SET/ E1 WA E2.
          WA (E1) WB E2 = k/MAKE-SET-/ WA (E1 WB) E2.
          WA (E1) = WA k/MAKE-SET/ E1.

    Видно, что первоначальное описание было короче и нагляд-
нее. кроме того, во втором описании пришлось использовать
вспомогательную функцию "MAKE-SET-".


                7. Спецификаторы переменных

    Любая переменная может иметь с п е ц и ф и к а ц и ю,
которая располагается между признаком типа переменной и ее
индексом.
    Спецификации позволяют накладывать дополнительные огра-
ничения на множества допустимых значений переменных. Напри-
мер, значением "SX" может быть любой символ, в то время как
значением "S('ABC')X" могут быть только символы-литеры 'A',
'B' и 'C'.
    Спецификация может иметь одну из следующих форм:
          [пусто]
          [имя спецификатора]
          ([спецификатор])
    Таким образом, если спецификация не пуста, она представ-
ляет собой либо имя спецификатора, либо непосредственно сам
спецификатор, заключенный в скобки. Между левой скобкой "("
и спецификатором, а также между спецификатором и правой
скобкой ")" можно вставлять пробелы. В то же время нельзя
вставлять пробелы между указателем типа и спецификацией, а
также между спецификацией и индексом переменной. Во всех
местах, где можно вставлять пробелы, можно также поставить
знак "+" и перенести предложение на следующую строку.
    Имя спецификатора выглядит так же, как символ-метка, за
исключением того, что в качестве ограничителей используются
не знаки "/", а знаки ":", т.е. имеет вид
               :[идентификатор]:
    Каждый спецификатор представляет собой описание некото-
рого множества термов. Это описание строится исходя из неко-
торого набора элементарных множеств, которые будут перечис-
лены ниже. Обозначения этих элементарных множеств именуются
э л е м е н т а м и.
    Допустимы следующие элементы.
    Во-первых, в качестве элементов могут использоваться
имена других спецификаторов. В этом случае имя спецификатора
обозначает множество, которое задает именуемый им специфика-
тор.
    Во-вторых, множество, состоящее из одного символа [S]
изображается самим этим символом. Таким образом, в качестве
элемента может использоваться любой символ.
    В третьих, имеется еще конечное множество элементов, пе-
речисленных ниже:
       S - множество всех символов;
       B - множество  термов   вида  "([E])",   где   [E]   -
           произвольное об'ектное выражение;
       W - множество всех термов;
       F - множество символов-меток;
       N - множество символов-чисел;
       R - множество символов-ссылок;
       O - множество символов-литер (об'ектных знаков);
       L - множество прописных букв (русских и латинских);
       D - множество десятичных цифр.

    Последовательность элементов спецификатора, называется ц
е п о ч к о й элементов. Цепочка элементов обозначает мно-
жество, которое представляет собой об'единение тех множеств,
которые соответствуют элементам цепочки. Таким образом, если
цепочка имеет вид

          X1 X2 ... XN

то она обозначает множество

          X1 + X2 + ... + XN

    где "+" обозначает об'единение множеств. Например, "LD"
обозначает множество букв и цифр.
    Между элементами цепочки можно вставлять произвольное
число пробелов. Если в цепочке элементов записано несколько
символов-литер подряд, их можно слить в одну цепочку литер.
Например,
                'A' 'B' '' 'C'

эквивалентно
                    'AB''C'

    В общем случае спецификатор имеет вид:

              P1(Q1)P2(Q2)...PN(QN)P0

    где "PK" и "QK" - произвольные (может быть пустые) це-
почки элементов спецификатора.
    Множество значений, изображаемое спецификатором, вычис-
ляется следующим образом.
    Если N=0, т.е. спецификатор имеет вид P0, то он изобра-
жает множество P0.
    Если N>0 и P0 - пусто, то следует в конце спецификатора
приписать элемент "W", т.е. считать P0 равным "W".
    После этого значение спецификатора вычисляется рекурсив-
но следующим образом. Пусть R' - это множество термов, изоб-
ражаемых спецификатором

          P2(Q2)...PN(QN)P0

    Тогда множество термов, изображаемое спецификатором

          P1(Q1)P2(Q2)...PN(QN)P0

вычисляется по формуле

          R = P1 + (R' - Q1)

    где "+" обозначает об'единение множеств, а "-" обознача-
ет разность множеств.
    Ниже приведены примеры спецификаторов. Для каждого спе-
цификатора описано множество, которое он изображает.

     'ABC' - любой из символов-литер 'A', 'B', 'C'.
     ('ABC')  -  любой терм,  за  исключением символов-литер
           'A', 'B', 'C'.
     ('A') L - любая буква, за исключением буквы 'A'.
     ('A')L('0')N -  любая буква,  за исключением  буквы 'A'
           или любая цифра, за исключением цифры '0'.

    Множество значений, обозначаемое спецификатором, можно
найти и другим способом. Можно рассматривать спецификатор
как предикат, который определен на множестве термов и для
каждого терма вырабатывает одно из двух значений: "истина"
или "ложь".
    Допустим, что задан некоторый терм и нужно узнать: удов-
летворяет он спецификатору или нет. Для этого просматриваем
спецификатор слева направо, элемент за элементом, пока не
встретим самый первый элемент, которому удовлетворяет прове-
ряемый терм. После этого спецификатор дальше не просматрива-
ется и вырабатывается значение "истина" или "ложь".
    Если найденный элемент принадлежит QK, т.е. находится
внутри скобок, то вырабатывается значение "ложь", а если
принадлежит рк, т.е. находится не в скобках, - то вырабаты-
вается значение "истина".
    Если же мы дошли до конца спецификатора и не нашли ни
одного элемента, которому удовлетворял бы проверяемый терм,
то следует посмотреть, чем заканчивается спецификатор. Если
он оканчивается на правую скобку, вырабатывается значение
"истина", в противном случае - "ложь".
    В соответствии с принятыми соглашениями пустой специфи-
катор обозначает пустое множество, а спецификатор вида "()"
- множество всех термов.
    Элементарные множества, обозначаемые элементами специфи-
катора, обладают следующим свойством: для любых двух элемен-
тарных множеств X1 и X2 либо пересечение X1 и X2 пусто, либо
X1 - подмножество X2, либо X2 - подмножество X1. Поэтому
можно доказать, что если два спецификатора представляют мно-
жества R1 и R2, то можно представить некоторыми спецификато-
рами также R1+R2, R1*R2 и R1-R2, где "+", "*" и "-" обозна-
чают об'единение, пересечение и разность множеств соответст-
венно. Таким образом, множество спецификаторов замкнуто от-
носительно теоретико-множественных операций.
    Имена спецификаторов описываются с помощью ключевого
слова "S". Эти описания имеют следующий вид:

[ID]     S  [S]

    где [ID] - имя спецификатора без ограничителей ":", а
[SP] - спецификатор. Например:

ADDOP    S  '+-'
MULTOP   S  '*/'

    Теперь, имена :ADDOP: и :MULTOP: можно употреблять в ка-
честве спецификаций и в качестве элементов других специфика-
торов. Например, значением переменных "S:ADDOP:х" и
"S(:ADDOP:)Y" может быть только '+' или '-'.
    Теперь опишем подробно, какой смысл имеют спецификации
для переменных различных типов.
    Спецификация вида ":ID:" равносильна спецификации
"(:ID:)". Например, переменная "S:ZZZ:1" имеет то же множес-
тво допустимых значений, что и переменная "S(:ZZZ:)1".
    Если спецификатор задан для S- или W-переменной, то это
означает, что значение переменной должно принадлежать мно-
жеству, которое описывает спецификатор.
    Если спецификатор задан для VE-переменной, то это озна-
чает, что каждый терм значения переменной, стоящий на нуле-
вом уровне скобочной структуры, должен удовлетворять специ-
фикатору.
    Например, E('+-')X - это последовательность (может быть
пустая) из литер '+' и '-', E(B)X - это выражение вида
(E1)(E2)...(EN) , а S(L)X E(LD)Y - это идентификатор.
    В то же время, E(('+-'))X - это выражение, которое не
содержит на нулевом уровне скобок ни одной литеры '+' или
'-'. Например, в качестве значения годится ('+')('-') , но
не годится '+'('-') .
    Если у переменной есть несколько вхождений в левую
часть, то у каждого вхождения может быть своя спецификация.
    Во время отождествления значение к а ж д о г о вхождения
должно удовлетворять спецификации э т о г о вхождения. Таким
образом, получается, что множество допустимых значений пере-
менной - это пересечение множеств допустимых значений ее
вхождений. Например:

         S(('A'))X S(('B'))X = SX

равносильно

         S(('AB'))X SX = SX

    Все спецификации, которые заданы для вхождений перемен-
ных в правую часть предложения - игнорируются.
    На использование имен спецификаторов наложено следующее
ограничение: если имя некоторого спецификатора используется
при описании другого спецификатора, то оно должно быть опи-
сано раньше.
    Благодаря этому ограничению запрещаются циклические оп-
ределения вроде

SPC1     S  :SPC2:
SPC2     S  :SPC1:

   Приведем примеры использования спецификаторов.

    Функция "IDENT" отщепляет от аргумента слева идентифика-
тор максимальной длины.

IDENT
          S(L)X E1 = k/IDENT1/ (SX) E1.
          E1 = '*' E1
IDENT1
          (EI) S(LD)A E1 = k/IDENT1/ (EI SA) E1.
          (EI) E1 = (EI) E1

    Если использовать отождествление справа налево и специ-
фицированные E-переменные, ту же функцию можно записать ко-
роче:

IDеNт    R S(L)X E(LD)Y E1 = (SX EY) E1
            E1 = '*' E1

    По семантике РЕФАЛа в первом предложении нужно подобрать
самое короткое "E1", при котором возможно отождествление. Но
ведь самому короткому "E1" соответствует самое длинное "EY"!
    Компилятор рефала распознает такие случаи, и вместо то-
го, чтобы несколько раз удлинять значение "E1", он сразу же,
слева направо наберет максимально возможное EY.
    Еще пример. Функция "ERASE-BL" просматривает цепочку
символов и заменяет каждую группу из нескольких последова-
тельно идущих пробелов на один пробел.

ERASE-BL
          E1 ' ' E2 = E1 ' ' k/ERASE-BL-/ E2.
          E1 = E1
 ERASE-BL-
          R E(' ')X E1 = k/ERASE-BL/ E1.


               8. Общая структура программы

    В системе программирования РЕФАЛ-2 тексты исходных РЕ-
ФАЛ-программ подготавливаются в виде последовательных фай-
лов, которые хранятся на машинных носителях. РЕФАЛ-программы
можно либо создавать с помощью стандартных редакторов текс-
тов.
    В любом случае РЕФАЛ-программа представляет собой после-
довательность з а п и с е й. Запись - это отдельная строка
текстового файла.
    Для совместимости с предыдущими реализациями РЕФАЛ-сис-
тема использует только первые 72 позиции, остальные позиции
игнорируются и обычно используются для нумерации записей.
Любой знак в 72 позиции эквивалентен знаку "+", т.е. означа-
ет продолжение Рефал-предложения в следующей записи.
    Все записи делятся на два класса: к о м м е н т а р и и
и д и р е к т и в ы.
    Записи-комментарии начинаются с литеры "*" (перед кото-
рой разрешается вставлять от 1 до 70 пробелов).
    В позициях после "*" они содержат произвольную информа-
цию. Эти записи игнорируются РЕФАЛ-системой и не влияют на
смысл РЕФАЛ-программы.
    Записи, которые не являются записями-комментариями, со-
держат директивы.
    РЕФАЛ-программа представляет собой последовательность д
и р е к т и в. Каждая директива занимает одну или несколько
рядом расположенных записей. Пока что будем предполагать,
что каждая директива занимает отдельную запись. Правила пе-
реноса директив с одной записи на другую будут описаны ниже.
   Все директивы имеют следующий вид:

[ID]     [KEY]    [INF]

    где [ID] - идентификатор, [KEY] - ключевое слово, кото-
рое представляет собой цепочку литер, не содержащую пробе-
лов, [INF] - информация, которая зависит от типа директивы.
    Присутствие всех трех компонентов директивы [ID], [KEY]
и [INF] - не обязательно: часть из них может отсутствовать.
[ID] отделяется от [KEY] одним или несколькими пробелами.
Если [ID] опущен, запись должна начинаться хотя бы с одного
пробела. [KEY] отделяется от [INF] одним или несколькими
пробелами. Если [KEY] опущено, а [INF] начинается с буквы,
перед [INF] должен быть хотя бы один пробел.
    Директива, в которой отсутствуют и [ID], и [KEY], и
[INF] (другими словами, состоящая из одних пробелов), явля-
ется п у с т о й. Пустые директивы не влияют на смысл РЕ-
ФАЛ-программы и могут использоваться для улучшения ее внеш-
него вида.
    В качестве ключевых слов допускаются следующие цепочки
литер:
                     EMPTY
                     END
                     ENTRY
                     EXTRN
                     L
                     R
                     S
                     SWAP
                     START

    Основное место в РЕФАЛ-программах занимают п р е д л о -
ж е н и я, которые служат для описания функций и с которыми мы
познакомились в предыдущих разделах. Предложения представля-
ют собой директивы с ключевым словом "L" или "R", причем
ключевое слово "L" разрешается опускать.
    Другой известный нам тип директив - это S-директивы, ко-
торые имеют ключевое слово "S" и служат для описания специ-
фикаторов.
    Директива, в которой присутствует [ID], но опущены [KEY]
и [INF] является признаком начала описания новой функции. А
именно, все последующие директивы-предложения, вплоть до на-
чала описания следующей функции, считаются относящимися к
функции [ID].
    Все прочие директивы будут описаны в последующих разде-
лах.
    В заключение опишем правила переноса директив с одной
записи на другую.
    Для перехода с одной записи на другую имеется два спосо-
ба:
     - литера  "+" в  любой  позиции,   в которой  допустимо
        вставить пробел;
     - любая литера, отличная от пробела, в 72 позиции.
    Назовем элементами предложения следующие об'екты: цепоч-
ку об'ектных знаков (заключенную в апострофы), составной
символ, свободную переменную, знаки "k", ".", "=", "(", ")".
    Между любыми двумя элементами предложения разрешается
вставлять произвольное число пробелов. Кроме того, разреша-
ется вставлять пробелы и между элементами спецификатора и
скобками, входящими в спецификатор. Например, "('A')LD" эк-
вивалентно " ( 'A' ) L D ". В то же время, нельзя вставлять
пробелы между признаком типа переменной и спецификацией, а
также между спецификацией и индексом переменной.
    Теперь правило переноса с помощью "+" формулируется сле-
дующим образом: в любом месте, где могут быть вставлены до-
полнительные незначащие пробелы, можно вставить знак "+" и
продолжить директиву с любой позиции следующей записи.

   П р и м е р.  Функцию

FUNC     E1 '+' E2 = (E1) '+' (E2) <PSI>
          S(('+-')ON)X = SX
          E1 = E1

можно записать следующим образом:

FUNC +
  E1     +
    '+'  +
      E2  +
     = +
       ( E1 +
         ) '+' (E2) k/PSI/.
          S(  +
          (   +
          '+-' +
          )    +
          O    +
          N    +
          )X = SX
          E1 =E1

    Второй способ переноса - любая литера, отличная от про-
бела, в 72 позиции.
    В этом случае (если перенос не был уже сделан с помощью
знака "+") первая позиция следующей записи считается непос-
редственно следующей за 71 позицией текущей записи. Таким
образом, директива может быть "разрезана" в любом месте.
    Второй способ переноса особенно удобен при автоматичес-
кой генерации РЕФАЛ-программ, так как можно сначала породить
директиву нужного размера, а затем нарезать ее на куски раз-
мером в 71 литеру.


                     9. Пустые функции

    В некоторых случаях возникает желание описывать пустые
функции, т.е. функции, описания которых содержат нулевое
число предложений. Эти функции имеют пустую область опреде-
ления, т.к. при любом обращении к такой функции возникает
останов "отождествление невозможно".
    Пустые функции обычно бывают полезны, если нужны симво-
лы, которые заведомо отличаются от всех остальных и которые
имеют удобные для человека графические представления.
    Пустые функции могут быть описаны с помощью директивы
"EMPTY", которая имеет следующий вид:

         EMPTY [идент1],[идент2],...,[идентN]

    где [идент1], [идент2], ..., [идентN] - имена определяе-
мых пустых функций. например:

         EMPTY ALPHA,PSI

    Пустые функции можно описывать и еще одним способом: с
первой позиции записывается идентификатор, а в следующих по-
зициях директивы остаются пробелы. Ключевое слово, таким об-
разом, в этом случае опускается. Например:

ALPHA
 PSI


                         10.Модули

    Часто бывает удобно разбить РЕФАЛ-программу на части,
которые могут обрабатываться компилятором РЕФАЛа независимо
друг от друга.
    Наименьшая часть РЕФАЛ-программы, которая может быть об-
работана компилятором независимо от других, называется  м о -
д у л е м.
    Результат компиляции исходного модуля на РЕФАЛе предс-
тавляет собой программу на ассемблере , ассемблируя который
получаем о б ' е к т н ы й модуль, который перед исполнением
РЕФАЛ-программы должен быть об'единен с другими модулями,
полученными компиляцией с РЕФАЛа или других языков. Это
об'единение выполняется с помощью редакторов связей и заг-
рузчиков. Детали зависят от используемой операционной систе-
мы.
    Исходный РЕФАЛ-модуль должен начинаться с директивы
"START" и кончаться директивой "END". Эти директивы имеют
следующий вид:

[ИМЯМОД] START
          END

    где [ИМЯМОД] - имя модуля, которое является цепочкой ла-
тинских букв и цифр длиной не более 8, начинающаяся с буквы.
Имя модуля может быть опущено.
    Функции, описанные в разных модулях, могут обращаться
друг к другу. Если в некотором модуле используется функция,
которая описана в другом модуле, эту функцию следует
об'явить в н е ш н е й по отношению к данному модулю с по-
мощью директивы "EXTRN".
    Если в некотором модуле описана функция, к которой есть
обращения из других модулей, эта функция должна быть об'яв-
лена в х о д н о й т о ч к о й данного модуля с помощью ди-
рективы "ENTRY".
    Директивы "ENTRY" и "EXTRN" имеют следующий вид:
         ENTRY [Ф1],[Ф2],...,[ФN]
         EXTRN [Ф1],[Ф2],...,[ФN]
    где [ФI] - описание входной точки или внешней метки со-
ответственно.
    [ФI] может иметь одну из двух следующих форм:
      [идентификатор]
      [идентификатор]([внешний идентификатор])
    где [внешний идентификатор] - это последовательность ла-
тинских букв и цифр длиной не более 8, начинающаяся с буквы.
    Если кроме имени функции задан еще внешний идентифика-
тор, это означает, что за пределами модуля (в среде, "окру-
жающей модули") функция имеет "внешнее" имя, которое отлича-
ется от "внутреннего" имени функции, употребляемого внутри
модуля. Таким образом одна и та же функция может иметь раз-
ные внутренние имена во всех модулях, в которых она исполь-
зуется, но ровно одно, одинаковое для всех модулей внешнее
имя.
    Если при описании функции в директиве "ENTRY" или
"EXTRN" внешнее имя не задано, то считается, что внешнее имя
совпадает с внутренним.
    Ограничения, налагаемые операционными системами, таковы,
что внешние имена могут содержать только латинские буквы и
иметь длину не более 8. Поэтому, в тех случаях, когда внут-
реннее имя содержит русские буквы, отличные от латинских или
имеет длину более 8 литер, следует указывать внешнее имя. В
случае слишком длинного имени оно усекается до 8 символов.
    П р и м е р. Пусть имеется два модуля "M1" и "M2". В мо-
дуле "M1" описана функция "COMMUNICATION", а в модуле "M2" -
функция "DREAM" и пусть эти функции используются в модулях
"M2" и "M1" соответственно. Тогда эти модули могут иметь
следующую структуру:

M1       START
          ENTRY COMMUNICATION(COMMUN)
          EXTRN DREAM
COMMUNICATION  E1 '+' E2 = +
                 k/DREAM/ E1. k/DREAM/ E2.
          END
M2       START
          ENTRY DREAM
          EXTRN общение(COMMUN)
DREAM    SX E1 = SX k/общение/ E1.
          END
    Здесь функция, которая имеет внутреннее имя "COMMUNICA-
TION" в модуле "M1", имеет внутреннее имя "общение" в модуле
"M2" и внешнее имя "COMMUN".
    С помощью директив "ENTRY" и "EXTRN" можно об'являть
входными и внешними не только имена функций, но и имена спе-
цификаторов.
    Каждое имя, которое употребляется внутри модуля, должно
быть описано либо как имя внутренней функции или специфика-
тора, либо как имя внешней функции или спецификатора в ди-
рективе "EXTRN".


                   11. Первичные функции

    Во многих случаях возникает необходимость из программ,
написанных на РЕФАЛе вызывать программы, написанные на дру-
гих языках или непосредственно в командах машины. Эта необ-
ходимость возникает, в частности, в тех случаях, когда тре-
буется выполнять операции ввода/вывода, операции над числами
и другие, которые рефал-машина "не умеет" выполнять непос-
редственно.
    Функции, описанные не на РЕФАЛе, которые, тем не менее,
можно вызывать обычным способом из программ, написанных на
РЕФАЛе, называются п е р в и ч н ы м и.
    Собственно говоря, с точки зрения РЕФАЛ-модуля первичные
функции - это просто некоторые функции, внешние по отношению
к данному модулю, поэтому, вызывая какую-либо функцию можно
даже не знать, что это - первичная функция или функция, на-
писанная на РЕФАЛе. Разница состоит только в том, что испол-
нение вызова первичной функции занимает только один шаг с
точки зрения РЕФАЛ-машины, в то время как исполнение вызова
обычной функции может занять несколько шагов.
    Набор первичных функций, предоставляемых в данной реали-
зации, будет описан отдельно. Помимо этих первичных функций
пользователь может писать и собственные на языке Си. Как это
сделать будет описано отдельно.


                        12.Копилка

    До сих пор мы считали, что РЕФАЛ-машина имеет два запо-
минающих устройства: поле памяти и поле зрения. В действи-
тельности у нее имеется еще одно запоминающее устройство: к
о п и л к а, доступ к которому возможен с помощью первичных
функций "BR", "DG", "CP", "RP", "DGALL".
    Имена этих функций имеют следующий смысл: "ВR" - зако-
пать (ВURY), "DG" - выкопать (DIG ОUТ), "СР" - скопировать
(СОРY), "RР" - заменить (RЕРLАСЕ).
    Содержимое копилки всегда имеет следующий вид:

          ([X1]'='[Y1]) ([X2]'='[Y2]) ... ([XN]'='[YN])

    где [X1], [X2], ..., [XN] и [Y1], [Y2], ..., [YN] - про-
извольные об'ектные выражения. Смысл содержимого копилки -
следующий. [ХI] - есть имя выражения [YI] .
    Перед началом работы программы копилка содержит пустое
выражение.
    Функции "ВR", "DG", "RР" и "СР" предназначены для пере-
мещения выражений из поля зрения в копилку и обратно. обра-
щения к ним имеют следующий вид:

          k/ВR/ [X] '=' [Y].
          k/DG/ [X].
          k/RР/ [X] '=' [Y].
          k/СР/ [X].

    где [Y] - произвольное выражение, а [Х] - произвольное
выражение, не содержащее символа '=' на нулевом уровне ско-
бочной структуры.
    Ф у н к ц и я "ВR" (закопать).
    При обращении к функции "ВR" терм "([Х] '=' [Y])" добав-
ляется к копилке слева, т.е. копилка преобразуется следующим
образом:

         [E]  -->  ([Х] '=' [Y]) [E]

    где [E] - содержимое копилки до обращения к "ВR". ре-
зультат обращения к "ВR" - пусто.
    можно закапывать несколько выражений под одним и тем же
именем. Например, в результате выполнения

         k/ВR/ 'X=A'. k/ВR/ 'X=B'.

копилка преобразуется следующим образом:

         [E]  -->  ('X=B')('X=A') [E]

    Ф у н к ц и я "DG" (выкопать).
    Функция "DG" просматривает копилку слева направо в поис-
ках терма вида "([X] '=' [Z])" и, если находит, удаляет его
из копилки и выдает [Z] в качестве результата замены. Это
можно изобразить следующим образом:

      поле зрения:  k/DG/ [X].  -->  [Z]
      копилка:      [E1] ([X] '=' [Z]) [E2]  -->  [E1][E2]

    Если в копилке несколько выражений закопаны под одним
именем, то выкапывается самое левое из них, т.е. то, которое
закапывалось последним. При повторном обращении к "DG" с тем
же аргументом [X] будет выкопано выражение, закопанное пред-
последним и т.д.
    Если "DG" не находит в копилке нужного терма, она выдает
в качестве результата замены пустое выражение.
    Ф у н к ц и я "СР" (скопировать).
    Функция "СР", так же, как и функция "DG", находит в ко-
пилке выражение по имени и выдает его в качестве результата
замены, но копилка при этом не изменяется, т.к. в поле зре-
ния формируется копия выражения. Таким образом "СР" работает
так:
     поле зрения:  k/CP/ [X].  --> [Y]
     копилка:      [E1] ([X] '=' [Y]) [E2]  -->
                         [E1] ([X] '=' [Y]) [E2]

    Если под именем [X] ничего не закопано, "СР" выдает
"пусто". Функцию "СР" можно было бы следующим образом опи-
сать через "ВR" и "DG":

CP       EX = k/CP1/ (EX) k/DG/ EX..
CP1      (EX) EY = EY k/BR/ EX '=' EY.

    Это описание несколько отличается от алгоритма, реализо-
ванного в первичной функции "СР", тем, что терм "([X] '='
[Y])" переставляется в начало копилки, в то время как пер-
вичная функция оставляет его на месте.
    Ф у н к ц и я "RР" (заменить).
    Функция "RР" добавляет в копилку новое выражение и выб-
расывает выражение, закопанное в последний раз под тем же
именем.

     поле зрения:  k/RP/ [X] '=' [Y].  -->  [пусто]
      копилка:      [E1] ([X] '=' [Z]) [E2]  -->
                           [E1] ([X] '=' [Y]) [E2]

    Если под именем [X] ничего не закопано, то функция "RР"
делает то же самое, что и "ВR".
    Эквивалентное описание на РЕФАЛе имеет вид:

RP       EX '=' EY = k/RP1/ k/DG/ EX.. k/BR/ EX '=' EY.
RP1      E1 =

    Ф у н к ц и я "DGАLL" (выкопать все).
    Функция "DGАLL" позволяет вынуть из копилки все содержи-
мое и поместить его в поле зрения. Обращение к "DGАLL" имеет
вид:
     k/DGALL/.

    Пусть копилка содержит выражение [E]. тогда результатом
обращения к "DGALL" будет [E] , причем в копилке останется
пустое выражение.
    Выражение [E] можно вернуть в копилку. Для этого доста-
точно описать на РЕФАЛе функцию "ВRАLL"

BRALL    E1 (E2) = k/BR/ E2. k/BRALL/ E1.
          =

    После этого следует обратиться к "ВRАLL" следующим обра-
зом:
         k/BRALL/ [E].


            13.Статические и динамические ящики

    Об'ектами обработки для программ, написанных на РЕФАЛе,
являются выражения. Выражение представляет собой по существу
способ представления древовидных структур в виде одномерных
цепочек символов и скобок.
    При решении некоторых задач, однако, оказывается, что
требуется обрабатывать структуры данных, которые сложнее,
чем древовидные.
    Конечно, в принципе, любые конструктивные об'екты можно
представить в виде деревьев, однако это не всегда удобно, а
иногда приводит к существенному замедлению работы программы
(в тех случаях, когда прямой доступ к данным приходится мо-
делировать с помощью ассоциативных поисков).
    Средством РЕФАЛа-2, дающим возможность обрабатывать про-
извольные графы, являются  с т а т и ч е с к и е  и  д и -
н а м и ч е с к и е  я щ и к и.
    До сих пор предполагалось, что РЕФАЛ-машина состоит из
трех запоминающих устройств: поля памяти, в котором находит-
ся набор предложений, поля зрения и копилки. Теперь будем
считать, что имеется еще потенциально бесконечное множество
запоминающих устройств, называемых я щ и к а м и. Каждый
ящик содержит произвольное об'ектное выражение, которое мо-
жет изменяться в процессе работы. Это выражение мы будем на-
зывать с о д е р ж и м ы м ящика.
    Каждому ящику соответствует функция, с помощью которой
можно получить доступ к содержимому ящика. Эти функции мы
будем называть о б м е н н ы м и.
    Таким образом, имеется взаимно-однозначное соответствие
между множеством обменных функций и множеством ящиков. Об-
менная функция, соответствующая некоторому ящику, будет на-
зываться также и м е н е м этого ящика.
    Наглядно взаимосвязь между ящиком и обменной функцией
можно изобразить следующим образом.

                      ---------
               FUNC : |  [E]  |
                      ---------

    где "FUNC" - имя обменной функции, а [E] - содержимое
ящика.
    Обменные функции работают следующим образом. После вы-
числения терма

          k/FUNC/ [E'].

    где "FUNC" - имя ящика, в поле зрения останется выраже-
ние [E] - содержимое ящика с именем "FUNC", а выражение [E']
станет содержимым ящика. Таким образом, происходит обмен ин-
формацией между полем зрения и ящиком (откуда и произошло
название обменных функций).
    Все ящики делятся на  с т а т и ч е с к и е  и  д и н а -
м и ч е с к и е. Статические ящики существуют в течение всего
времени выполнения программы и не могут ни порождаться, ни
уничтожаться во время работы. Напротив, динамические ящики
порождаются только во время работы и могут уничтожаться.
    Все с т а т и ч е с к и е ящики должны быть описаны в
программе. Для этого используются директивы "SWAP", которые
выглядят следующим образом:

         SWAP   [идент1],[идент2],...,[идентN]

    Т.е., пропустив один или несколько пробелов, следует за-
писать ключевое слово "SWAP", затем пропустить один или нес-
колько пробелов и перечислить через запятую имена обменных
функций.
    Таким образом, статические ящики описываются одновремен-
но со своими обменными функциями. Перед началом работы прог-
раммы все статические ящики содержат пустые выражения.
    П р и м е р. Рассмотрим следующий фрагмент программы:

         SWAP  X1,X2
 SWX1X2   = k/X1/ 'A'. k/X2/ 'B'. k/SW2/ /X1/ /X2/.
 SW2      SX SY = k SX k SY k SX...

   В процессе вычисления обращения

         k/SWX1X2/.

    в ящики "X1" и "X2" сначала занесутся символы 'A' и 'B'
соответственно. Затем, в результате вычисления терма

         k/SW2/ /X1/ /X2/.

    содержимые ящиков поменяются местами. То есть в ящике
"X1" окажется символ 'B' , в ящике "X2" - символ 'A' , а в
поле зрения останется пустой результат замены.
    Д и н а м и ч е с к и е ящики порождаются в процессе ра-
боты программы первичной функцией "NEW".
    Ф у н к ц и я "NEW".
    В результате вычисления терма

         k/NEW/ [E].

    создается новый ящик и в него помещается выражение [E].
Одновременно порождается новый символ-ссылка [R], который
остается в поле зрения в качестве результата замены. Символ
[R] является именем новой обменной функции, обеспечивающей
доступ к созданному ящику.
    Имена динамических ящиков являются символами особого ти-
па - символами-ссылками. В отличие от имен статических ящи-
ков, являющихся обычными символами-метками, символы-ссылки
нельзя употреблять в виде констант в рефал-программах. Тем
не менее, при отладке рефал-программ возникает необходимость
как-то печатать символы-ссылки. Они печатаются в виде

         /%FFFFFF/
    где "FFFFFF" - шесть шестнадцатеричных цифр, обладающих
следующими свойствами:
     - в   каждый   момент    работы   программы   различным
        символам-ссылкам соответствуют различные "FFFFFF"
     - один  и  тот же  символ-ссылка  имеет  одно и  то  же
        "FFFFFF" на протяжении одного запуска программы
    Эти свойства выполняются в силу того, что "FFFFFF" пред-
ставляет собой адрес места, в котором расположен динамичес-
кий ящик в памяти машины.
    П р и м е р. Рассмотрим следующий фрагмент программы,
аналогичный приведенному в предыдущем примере.

         EXTRN NEW
 SWR1R2   = k/SW2/ k/NEW/ 'A'. k/NEW/ 'B'..
 SW2      SX SY = k SX k SY k SX...

    Теперь, в результате вычисления терма "k/SWR1R2/." будут
выполнены два обращения к функции "NEW". В результате чего
образуются два ящика, которые могут иметь, например, следую-
щие имена: "/%070613/" и "/%053024/". Ящик "/%070613/" будет
содержать символ 'A', а ящик "/%053024/" - символ 'B'. Затем
функция "SW2" воспользуется символами-ссылками, оставшимися
в поле зрения, и поменяет местами содержимое этих ящиков.
    Обратите внимание на следующий факт: обращение к функции
"SWR1R2" привело к появлению двух новых ящиков. Можно ли те-
перь как-нибудь извлечь содержимое этих ящиков? Очевидно,
что нельзя. Ни в поле зрения, ни в копилке, ни в других ящи-
ках не сохранилось имен этих ящиков. Поэтому дальнейшая ра-
бота программы не изменится, если эти ящики уничтожить.
    Ясно, что если обращаться к функции "SWR1R2" много раз,
то память РЕФАЛ-машины будет забиваться ненужными ящиками.
Конечно, для абстрактной РЕФАЛ-машины это не имеет никакого
значения, ибо ее память потенциально бесконечна, но память
реальной вычислительной машины рано или поздно должна исчер-
паться. Поэтому во всех реализациях РЕФАЛа-2 предусмотрен
механизм   с б о р к и   м у с о р а.
    Сборка мусора автоматически запускается каждый раз, ког-
да исчерпается свободная память. При этом обнаруживаются и
удаляются все ящики, к которым невозможно добраться прямо
или косвенно из поля зрения, копилки или статических ящиков.
На следующем рисунке изображены поле зрения, копилка и дина-
мические ящики, пронумерованные цифрами от 1 до 8. Звездочки
изображают некоторые элементы выражений, которые не являются
символами-ссылками. Символы-ссылки обозначены цифрами.

       поле зрения               копилка
   * * 1 * * * * * * *      * 2 * * * * * * *
     (1): * * 4    (2): 4 * 5   (3): * 5
         (4): * *    (5): * 6 3    (7): 3 8    (8): 7 *
                (6): * 4 *

    Видно, что по ссылке из поля зрения можно добраться до
ящика 1, а из него - до ящика 4. Из копилки можно непосредс-
твенно добраться до ящика 2 и косвенно (через ящик 2) до
ящиков 4, 5, 6, 3. Таким образом, нет способа извлечь инфор-
мацию из ящиков 7 и 8. Если в этот момент запустить сборку
мусора, то ящики 7 и 8 будут уничтожены. Если теперь убрать
символ-ссылку из поля зрения, то станет недоступным и ящик
1. Если же символ-ссылку в поле зрения оставить, но убрать
ссылку из копилки, то окажутся ненужными все ящики, кроме 1
и 4.
    Опишем теперь пять первичных функций, которые, хотя и не
дают ничего принципиально нового, часто оказываются удобны-
ми.

    Ф у н к ц и я "GTR" (взять по ссылке).
    Извлекает содержимое ящика. Результатом замены при вы-
числении терма

         k/GTR/ [X].

    где [X] - имя статического или динамического ящика, яв-
ляется содержимое ящика. При этом в ящике остается пустое
выражение.

    Ф у н к ц и я "RDR" (прочитать по ссылке).
    Как и "GTR" выдает содержимое ящика в поле зрения, но
ящик при этом не изменяется, то есть происходит копирование
его содержимого.

    Ф у н к ц и я "PTR" (положить по ссылке).
    Добавляет в ящик новую информацию. В результате вычисле-
ния терма

     k/PTR/ [R] [E].
    где [R] - имя ящика, а [E] - произвольное об'ектное вы-
ражение, ящик меняется так:

     [E0]  -->  [E0][E]

    где [E0] - старое содержимое ящика. Результатом замены
является пустое выражение.

    Ф у н к ц и я "WTR" (записать по ссылке). Помещает в
ящик новую информацию, при этом старое содержимое ящика
уничтожается. То есть при вычислении терма

     k/WTR/ [R] [E].

    где [R] - имя ящика, [E] - произвольное об'ектное выра-
жение, содержимое ящика меняется так

      [E0]  -->  [E]

где  [E0]  -  старое содержимое  ящика.  Результатом  замены
 является пустое выражение.

   Ф у н к ц и я  "SWR"  (обменять по ссылке).
    Записывает в ящик новую информацию, а старую выдает в
поле зрения. Таким образом происходит такое преобразование

     поле зрения:  k/SWR/ [R] [E].   -->  [E0]
      ящик:         [E0]  -->  [E]

где [R] - имя ящика, [E] - об'ектное выражение.

    Эти функции можно было бы описать на РЕФАЛе следующим
образом:

GTR      SX = k SX.
 RDR      SX = k/RDR1/ SX k SX..
 RDR1     SX EY = EY k SX EY.
 PTR      SX EY = k SX k SX. EY.
 WTR      SX EY = k/WTR1/ k SX EY..
 WTR1     EY =
 SWR      SX EY = k SX EY.

    Отличие этих функций от соответствующих первичных функ-
ций состоит в том, что они не проверяют, что "SX" - имя ящи-
ка, поэтому их область определения шире, чем у соответствую-
щих первичных функций.
